
\section{Introduction: Generative Models}
Given observed samples $\bm{x}$ from a distribution of interest, the goal of a \textbf{generative model} is to learn to \textit{model} its true data distribution $p(\bm{x})$.  Once learned, we can \textit{generate} new samples from our approximate model at will.  Furthermore, under some formulations, we are able to use the learned model to evaluate the likelihood of observed or sampled data as well.

There are several well-known directions in current literature, that we will only introduce briefly at a high level.  Generative Adversarial Networks (GANs) model the sampling procedure of a complex distribution, which is learned in an adversarial manner.  Another class of generative models, termed "likelihood-based", seeks to learn a model that assigns a high likelihood to the observed data samples.  This includes autoregressive models, normalizing flows, and Variational Autoencoders (VAEs).  Another similar approach is energy-based modeling, in which a distribution is learned as an arbitrarily flexible energy function that is then normalized.  Score-based generative models are highly related; instead of learning to model the energy function itself, they learn the \textit{score} of the energy-based model as a neural network.  In this work we explore and review diffusion models, which as we will demonstrate, have both likelihood-based and score-based interpretations.  We showcase the math behind such models in excruciating detail, with the aim that anyone can follow along and understand what diffusion models are and how they work.

\section*{Background: ELBO, VAE, and Hierarchical VAE}
\addcontentsline{toc}{section}{\protect\numberline{}Background: ELBO, VAE, and Hierarchical VAE}%

For many modalities, we can think of the data we observe as represented or generated by an associated unseen \textit{latent} variable, which we can denote by random variable $\bm{z}$.  The best intuition for expressing this idea is through Plato's \href{https://en.wikipedia.org/wiki/Allegory_of_the_cave}{Allegory of the Cave}.  In the allegory, a group of people are chained inside a cave their entire life and can only see the two-dimensional shadows projected onto a wall in front of them, which are generated by unseen three-dimensional objects passed before a fire.  To such people, everything they observe is actually determined by higher-dimensional abstract concepts that they can never behold.

Analogously, the objects that we encounter in the actual world may also be generated as a function of some higher-level representations; for example, such representations may encapsulate abstract properties such as color, size, shape, and more.  Then, what we observe can be interpreted as a three-dimensional projection or instantiation of such abstract concepts, just as what the cave people observe is actually a two-dimensional projection of three-dimensional objects.  Whereas the cave people can never see (or even fully comprehend) the hidden objects, they can still reason and draw inferences about them; in a similar way, we can approximate latent representations that describe the data we observe.

Whereas Plato’s Allegory illustrates the idea behind latent variables as potentially unobservable representations that determine observations, a caveat of this analogy is that in generative modeling, we generally seek to learn lower-dimensional latent representations rather than higher-dimensional ones.  This is because trying to learn a representation of higher dimension than the observation is a fruitless endeavor without strong priors.  On the other hand, learning lower-dimensional latents can also be seen as a form of compression, and can potentially uncover semantically meaningful structure describing observations.


\subsubsection*{Evidence Lower Bound}
\addcontentsline{toc}{section}{\protect\numberline{}\protect\numberline{}Evidence Lower Bound}%

Mathematically, we can imagine the latent variables and the data we observe as modeled by a joint distribution $p(\bm{x}, \bm{z})$.  Recall one approach of generative modeling, termed "likelihood-based", is to learn a model to maximize the likelihood $p(\bm{x})$ of all observed $\bm{x}$.  There are two ways we can manipulate this joint distribution to recover the likelihood of purely our observed data $p(\bm{x})$; we can explicitly \href{https://en.wikipedia.org/wiki/Marginal_likelihood}{marginalize} out the latent variable $\bm{z}$:
\begin{equation}
\label{eq:1}
p(\bm{x}) = \int p(\bm{x}, \bm{z})d\bm{z}
\end{equation}
or, we could also appeal to the \href{https://en.wikipedia.org/wiki/Chain_rule_(probability)}{chain rule of probability}:
\begin{equation}
\label{eq:2}
p(\bm{x}) = \frac{p(\bm{x}, \bm{z})}{p(\bm{z}|\bm{x})}
\end{equation}
Directly computing and maximizing the likelihood $p(\bm{x})$ is difficult because it either involves integrating out all latent variables $\bm{z}$ in Equation \ref{eq:1}, which is intractable for complex models, or it involves having access to a ground truth latent encoder $p(\bm{z}|\bm{x})$ in Equation \ref{eq:2}.  However, using these two equations, we can derive a term called the \textbf{E}vidence \textbf{L}ower \textbf{Bo}und (ELBO), which as its name suggests, is a \href{https://en.wikipedia.org/wiki/Upper_and_lower_bounds}{lower bound} of the evidence.  The evidence is quantified in this case as the log likelihood of the observed data.  Then, maximizing the ELBO becomes a proxy objective with which to optimize a latent variable model; in the best case, when the ELBO is powerfully parameterized and perfectly optimized, it becomes exactly equivalent to the evidence.  Formally, the equation of the ELBO is:
\begin{equation}
\mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log\frac{p(\bm{x}, \bm{z})}{q_{\bm{\phi}}(\bm{z}|\bm{x})}\right]
\end{equation}
To make the relationship with the evidence explicit, we can mathematically write:
\begin{equation}
\log p(\bm{x}) \geq \mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log\frac{p(\bm{x}, \bm{z})}{q_{\bm{\phi}}(\bm{z}|\bm{x})}\right]
\end{equation}
Here, $q_{\bm{\phi}}(\bm{z}|\bm{x})$ is a flexible approximate variational distribution with parameters $\bm{\phi}$ that we seek to optimize.  Intuitively, it can be thought of as a parameterizable model that is learned to estimate the true distribution over latent variables for given observations $\bm{x}$; in other words, it seeks to approximate true posterior $p(\bm{z}|\bm{x})$.  As we will see when exploring the Variational Autoencoder, as we increase the lower bound by tuning the parameters $\bm{\phi}$ to maximize the ELBO, we gain access to components that can be used to model the true data distribution and sample from it, thus learning a generative model.  For now, let us try to dive deeper into why the ELBO is an objective we would like to maximize.

Let us begin by deriving the ELBO, using Equation \ref{eq:1}:
\begin{align}
\log p(\bm{x}) & = \log \int p(\bm{x}, \bm{z})d\bm{z} && \text{(Apply Equation \ref{eq:1})}\\
           & = \log \int \frac{p(\bm{x}, \bm{z})q_{\bm{\phi}}(\bm{z}|\bm{x})}{q_{\bm{\phi}}(\bm{z}|\bm{x})}d\bm{z} && \text{(Multiply by $1 = \frac{q_{\bm{\phi}}(\bm{z}|\bm{x})}{q_{\bm{\phi}}(\bm{z}|\bm{x})}$)}\\
           & = \log \mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\frac{p(\bm{x}, \bm{z})}{q_{\bm{\phi}}(\bm{z}|\bm{x})}\right] && \text{(Definition of Expectation)}\\
           & \geq \mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log \frac{p(\bm{x}, \bm{z})}{q_{\bm{\phi}}(\bm{z}|\bm{x})}\right] && \text{(Apply \href{https://en.wikipedia.org/wiki/Jensen\%27s_inequality}{Jensen's Inequality})} \label{eq:8}
\end{align}
In this derivation, we directly arrive at our lower bound by applying Jensen's Inequality.  However, this does not supply us much useful information about what is actually going on underneath the hood; crucially, this proof gives no intuition on exactly why the ELBO is actually a lower bound of the evidence, as Jensen's Inequality handwaves it away.  Furthermore, simply knowing that the ELBO is truly a lower bound of the data does not really tell us why we want to maximize it as an objective.  To better understand the relationship between the evidence and the ELBO, let us perform another derivation, this time using Equation \ref{eq:2}:
% \begin{align}
% \log p(\bm{x}) & = \log p(\bm{x}) \int q_{\bm{\phi}}(\bm{z}|\bm{x})dz && \text{(Multiply by $1 = \int q_{\bm{\phi}}(\bm{z}|\bm{x})d\bm{z}$)}\\
%           & = \int q_{\bm{\phi}}(\bm{z}|\bm{x})(\log p(\bm{x}))dz && \text{(Bring evidence into integral)}\\
%           & = \mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log p(\bm{x})\right] && \text{(Definition of Expectation)}\\
%           & = \mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log\frac{p(\bm{x}, \bm{z})}{p(\bm{z}|\bm{x})}\right]&& \text{(Apply Equation \ref{eq:2})}\\
%           & = \mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log\frac{p(\bm{x}, \bm{z})q_{\bm{\phi}}(\bm{z}|\bm{x})}{p(\bm{z}|\bm{x})q_{\bm{\phi}}(\bm{z}|\bm{x})}\right]&& \text{(Multiply by $1 = \frac{q_{\bm{\phi}}(\bm{z}|\bm{x})}{q_{\bm{\phi}}(\bm{z}|\bm{x})}$)}\\
%           & = \mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log\frac{p(\bm{x}, \bm{z})}{q_{\bm{\phi}}(\bm{z}|\bm{x})}\right] + \mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log\frac{q_{\bm{\phi}}(\bm{z}|\bm{x})}{p(\bm{z}|\bm{x})}\right] && \text{(Split the Expectation)}\\
%           & = \mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log\frac{p(\bm{x}, \bm{z})}{q_{\bm{\phi}}(\bm{z}|\bm{x})}\right] + D_{\rm{KL}}{q_{\bm{\phi}}(\bm{z}|\bm{x})}{p(\bm{z}|\bm{x})}  && \text{(Definition of \href{https://en.wikipedia.org/wiki/Kullback\%E2\%80\%93Leibler_divergence}{KL Divergence})}\label{eq:15}\\
%           & \geq \mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log\frac{p(\bm{x}, \bm{z})}{q_{\bm{\phi}}(\bm{z}|\bm{x})}\right]  && \text{(KL Divergence always $\geq 0$)}
% \end{align}
From this derivation, we clearly observe from Equation \ref{eq:15} that the evidence is equal to the ELBO plus the KL Divergence between the approximate posterior $q_{\bm{\phi}}(\bm{z}|\bm{x})$ and the true posterior $p(\bm{z}|\bm{x})$.  In fact, it was this KL Divergence term that was magically removed by Jensen's Inequality in Equation \ref{eq:8} of the first derivation.  Understanding this term is the key to understanding not only the relationship between the ELBO and the evidence, but also the reason why optimizing the ELBO is an appropriate objective at all.

Firstly, we now know why the ELBO is indeed a lower bound: the difference between the evidence and the ELBO is a strictly non-negative KL term, thus the value of the ELBO can never exceed the evidence.

Secondly, we explore why we seek to maximize the ELBO.  Having introduced latent variables $\bm{z}$ that we would like to model, our goal is to learn this underlying latent structure that describes our observed data.  In other words, we want to optimize the parameters of our variational posterior $q_{\bm{\phi}}(\bm{z}|\bm{x})$ to exactly match the true posterior distribution $p(\bm{z}|\bm{x})$, which is achieved by minimizing their KL Divergence (ideally to zero).  Unfortunately, it is intractable to minimize this KL Divergence term directly, as we do not have access to the ground truth $p(\bm{z}|\bm{x})$ distribution.  However, notice that on the left hand side of Equation \ref{eq:15}, the likelihood of our data (and therefore our evidence term $\log p(\bm{x})$) is always a constant with respect to $\bm{\phi}$, as it is computed by marginalizing out all latents $\bm{z}$ from the joint distribution $p(\bm{x}, \bm{z})$ and does not depend on $\bm{\phi}$ whatsoever.  Since the ELBO and KL Divergence terms sum up to a constant, any maximization of the ELBO term with respect to $\bm{\phi}$ necessarily invokes an equal minimization of the KL Divergence term.  Thus, the ELBO can be maximized as a proxy for learning how to perfectly model the true latent posterior distribution; the more we optimize the ELBO, the closer our approximate posterior gets to the true posterior.  Additionally, once trained, the ELBO can be used to estimate the likelihood of observed or generated data as well, since it is learned to approximate the model evidence $\log p(\bm{x})$.

\section{VAE : Variational Autoencoders}
\subsection{自己符号化 autoencoder}
条件付き確率とは，観測データが与えられたときの確率分布を表していた．興味のある確率分布を作りたいとする．このとき，潜在変数，隠れ変数とも呼ぶを用いれば，より複雑なモデルを形成でき，目的の確率分布に近い分布を生成できる． 
\begin{equation}
    p(\bm{x}) \simeq q_{\theta}(\bm{x})
    =\sum_{\bm{z}} q_{\theta}(\bm{x}, \bm{z})
    =\sum_{\bm{z}} q_{\theta}(\bm{x}|\bm{z})
    q_{\theta}(\bm{z})
\end{equation}
ここで，潜在変数に関する確率分布$q_{\theta}(\bm{z})$には，わかりやすい簡単な既知の確率分布を用いる．例えばGauss分布など．そして，我々が学習する分布は$q_{\theta}(\bm{x}|\bm{z})$である．

エンコードとは，エンコーダ内のニューラルネットワーク$\mathcal{F}(\dot,\mathcal{W})$を用いて，観測データ$\bm{x}$を潜在変数$\bm{z}=\mathcal{F}(\bm{x},\mathcal{W})\in\mathbb{R}^{N_{\rm{latent}}}$に変換すること．

デコードとは，デコード内のニューラルネットワーク$\Tilde{\mathcal{F}}(\dot,\Tilde{\mathcal{W}})$を用いて，潜在変数$\bm{z}$を元の入力$\bm{x}$の近似値$\Tilde{\bm{x}}=\Tilde{\mathcal{F}}(\bm{z},\Tilde{\mathcal{W}})\in\mathbb{R}^{N_{\rm{in}}}$に変換すること．
\begin{figure}
  \centering
  %includegraphics[width=0.25\linewidth]{images/vae.png}
  \caption{A Variational Autoencoder graphically represented.  Here, encoder $q(\bm{z}|\bm{x})$ defines a distribution over latent variables $\bm{z}$ for observations $\bm{x}$, and $p(\bm{x}|\bm{z})$ decodes latent variables into observations.}
  \label{fig:vae}
\end{figure}

\subsection{VAE}
In the default formulation of the Variational Autoencoder (VAE)~\cite{kingma2013auto}, we directly maximize the ELBO.  This approach is \textit{variational}, because we optimize for the best $q_{\bm{\phi}}(\bm{z}|\bm{x})$ amongst a family of potential posterior distributions parameterized by $\bm{\phi}$.  It is called an \textit{autoencoder} because it is reminiscent of a traditional autoencoder model, where input data is trained to predict itself after undergoing an intermediate bottlenecking representation step.  To make this connection explicit, let us dissect the ELBO term further:
ELBO項を次のように分解する：
\begin{align}
&{\mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log\frac{q_{\Vec{\theta}}(\bm{x}, \bm{z})}{q_{\bm{\phi}}(\bm{z}|\bm{x})}\right]}\nn[10pt]
&= {\mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log\frac{q_{\Vec{\theta}}(\bm{x}|\bm{z})q_{\Vec{\theta}}(\bm{z})}{q_{\bm{\phi}}(\bm{z}|\bm{x})}\right]}\ {\text{(Chain Rule of Probability)}}\\
&= {\mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log p_{\bm{\theta}}(\bm{x}|\bm{z})\right] + \mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log\frac{p(\bm{z})}{q_{\bm{\phi}}(\bm{z}|\bm{x})}\right]} \ {\text{(Split the Expectation)}}\\
&=\textcolor{blue}{
\underbrace{{\mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log p_{\bm{\theta}}(\bm{x}|\bm{z})\right]}}_\text{reconstruction term}
}
- \underbrace{{D_{\rm{KL}}{q_{\bm{\phi}}(\bm{z}|\bm{x})}{p(\bm{z})}}}_\text{prior matching term} \ {\text{(Definition of KL Divergence)}}\label{eq:19}
\end{align}

ここで， \eqref{eq:19}の2項は次のように直観的に解釈できる：reconstruction term : $\mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log p_{\bm{\theta}}(\bm{x}|\bm{z})\right]$は$\Vec{z}$から$\Vec{x}$に戻せるか？，デコードが正確に行われいるかを測る．この量が大きければ，デコードが正確に行われていることを意味する．

% $\Vec{x}$から$\Vec{z}$を生成に関する確率分布$q_{\bm{\phi}}(\bm{z}|\bm{x})$これは，学習された分布が，元のデータを再生することができる有効な潜在値をモデル化していることを保証する． 

一方で，prior matching term : $D_{\rm{KL}}{q_{\bm{\phi}}(\bm{z}|\bm{x})}{p(\bm{z})}$は，エンコードが正確にできているかその精度を表している．この量が小さければ，エンコードが正確に行われていることを意味する．

% 第2項は，学習された変分分布が，潜在変数に対して保持されている事前信念にどれだけ似ているかを測定します． 
% この項を最小化することで，エンコーダはディラック・デルタ関数に陥るのではなく，実際に分布を学習するようになる． 

したがって，ELBOを最大化することは第1項を最大化し，第2項を最小化することと等価である．

VAEの特徴として，ELBOがパラメータ$\bm{\phi}$と$\bm{\theta}$の両方に関して最適化される．
VAEのencoderは，一般的には，平均ベクトル$\bm{\mu}$，共分散行列が対角化されており，対角要素に$\bm{\phi}^2(\bm{x})$を持つ多変量ガウス分布をモデル化し，事前分布には，平均ベクトル$\bm{0}$，共分散行列が単位行列でできた多変量標準ガウス分布を仮定することが多い：
\begin{align}
    q_{\bm{\phi}}(\bm{z}|\bm{x}) &= \mathcal{N}(\bm{z}; \bm{\mu}_{\bm{\phi}}(\bm{x}), \bm{\sigma}_{\bm{\phi}}^2(\bm{x})\textbf{I})\\
    p(\bm{z}) &= \mathcal{N}(\bm{z}; \bm{0}, \textbf{I})
\end{align}
このとき，ELBOのKLダイバージェンスの項は解析的に求めることができる．また，reconstruction termはモンテカルロ推定によって近似的に求めることができる．そして，ELBOを最大化するという我々の目的は以下のように書き換えられる:
\begin{align}
    {\argmax_{\bm{\phi}, \bm{\theta}}} \mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log p_{\bm{\theta}}(\bm{x}|\bm{z})\right] - D_{\rm{KL}}{q_{\bm{\phi}}(\bm{z}|\bm{x})}{p(\bm{z})} \approx \argmax_{\bm{\phi}, \bm{\theta}} \sum_{l=1}^{L}\log p_{\bm{\theta}}(\bm{x}|\bm{z}^{(l)}) - D_{\rm{KL}}{q_{\bm{\phi}}(\bm{z}|\bm{x})}{p(\bm{z})}
\end{align}
where latents $\{\bm{z}^{(l)}\}_{l=1}^L$ are sampled from $q_{\bm{\phi}}(\bm{z}|\bm{x})$, for every observation $\bm{x}$ in the dataset.  However, a problem arises in this default setup: each $\bm{z}^{(l)}$ that our loss is computed on is generated by a stochastic sampling procedure, which is generally non-differentiable.  Fortunately, this can be addressed via the \textit{reparameterization trick} when $q_{\bm{\phi}}(\bm{z}|\bm{x})$ is designed to model certain distributions, including the multivariate Gaussian.
各項の計算の詳細について解析していく．
\subsubsection{負のKLダイバージェンスの解析：1変数の場合}
\begin{align}
    D_{\rm{KL}}(q_{\Vec{\phi}}(\Vec{z}|\Vec{x})\| q_0(\Vec{z}))
    &=\int\ dx \frac{1}{\sqrt{2\pi{\sigma_{\Vec{\phi}}}^2}}
    \exp{
    \left(
    -\frac{1}{2{\sigma_{\Vec{\phi}}}^2}
    (z-\mu_{\Vec{\phi}})^2
    \right)
    }\nn
    &\hspace{20pt}
    \times \left\{
    -\frac{1}{2{\sigma_{\Vec{\phi}}}^2}
    (z-\mu_{\Vec{\phi}})^2
    -\frac{1}{2}\log2\pi {\sigma_{\Vec{\phi}}}^2
    +\frac{1}{2}z^2
    +\frac{1}{2} \ln 2\pi
    \right\}\\[10pt]
    & =
    \frac{1}{2}
    (
    {\mu_{\Vec{\phi}}}
    +{\sigma_{\Vec{\phi}}}^2
    -1-\ln{{\sigma_{\Vec{\phi}}}^2}
    )
\end{align}



\subsubsection{負のKLダイバージェンスの解析：多変数の場合}

\subsubsection{reconstruction term：1変数の場合}

\subsubsection{reconstruction term：多変数の場合}

The reparameterization trick rewrites a random variable as a deterministic function of a noise variable; this allows for the optimization of the non-stochastic terms through gradient descent.  For example, samples from a normal distribution $x \sim \mathcal{N}(x;\mu, \sigma^2)$ with arbitrary mean $\mu$ and variance $\sigma^2$ can be rewritten as:
\begin{align*}
    x &= \mu + \sigma\epsilon \quad \text{with } \epsilon \sim \mathcal{N}(\epsilon; 0, \eye)
\end{align*}
In other words, arbitrary Gaussian distributions can be interpreted as standard Gaussians (of which $\epsilon$ is a sample) that have their mean shifted from zero to the target mean $\mu$ by addition, and their variance stretched by the target variance $\sigma^2$.  Therefore, by the reparameterization trick, sampling from an arbitrary Gaussian distribution can be performed by sampling from a standard Gaussian, scaling the result by the target standard deviation, and shifting it by the target mean.

In a VAE, each $\bm{z}$ is thus computed as a deterministic function of input $\bm{x}$ and auxiliary noise variable $\bm{\epsilon}$:
\begin{align*}
    \bm{z} &= \bm{\mu}_{\bm{\phi}}(\bm{x}) + \bm{\sigma}_{\bm{\phi}}(\bm{x})\odot\bm{\epsilon} \quad \text{with } \bm{\epsilon} \sim \mathcal{N}(\bm{\epsilon};\bm{0}, \textbf{I})
\end{align*}
where $\odot$ represents an element-wise product.  Under this reparameterized version of $\bm{z}$, gradients can then be computed with respect to $\bm{\phi}$ as desired, to optimize $\bm{\mu}_{\bm{\phi}}$ and $\bm{\sigma}_{\bm{\phi}}$.  The VAE therefore utilizes the reparameterization trick and Monte Carlo estimates to optimize the ELBO jointly over $\bm{\phi}$ and $\bm{\theta}$.

After training a VAE, generating new data can be performed by sampling directly from the latent space $p(\bm{z})$ and then running it through the decoder.  Variational Autoencoders are particularly interesting when the dimensionality of $\bm{z}$ is less than that of input $\bm{x}$, as we might then be learning compact, useful representations.  Furthermore, when a semantically meaningful latent space is learned, latent vectors can be edited before being passed to the decoder to more precisely control the data generated.

\subsection{Hierarchical Variational Autoencoders}
\addcontentsline{toc}{section}{\protect\numberline{}\protect\numberline{}Hierarchical Variational Autoencoders}%

A Hierarchical Variational Autoencoder (HVAE)~\cite{kingma2016improved, sonderby2016ladder}は，潜在変数に関する複数の階層に拡張するVAEの一般化である．この定式化のもとでは，潜在変数それ自体は，他の上位の，より抽象的な潜在変数から生成されたものとして解釈される．直観的には，我々が3次元の観察対象をより高次の抽象的な潜在変数から生成されたものとして扱うように，プラトンの洞窟の人々は3次元の物体を2次元の観察を生成する潜在変数として扱う． したがって，プラトンの洞窟の住人の観点からは，彼らの観察は深さ2（またはそれ以上）の潜在階層によってモデル化されたものとして扱うことができる． 階層レベル$T$の一般的なHVAEでは，各潜在変数は，すべての前の潜在変数に条件付けすることが許されるが，ここでは，Markov HVAE (MHVAE)と呼ぶ特別なケースに注目する． MHVAEでは，生成過程はMarkov連鎖である．つまり，階層を下る各遷移はMarkov的であり，各潜在変数$\bm{z}_t$をdecodeすｒことは，その前の潜在変数$\bm{z}_{t+1}$のみによって条件づけられる． 直感的に，また視覚的に，これは図に描かれているように，単にVAEを積み重ねていることと同じである．数学的には，Markov型HVAEの結合分布 (joint distribution)と事後分布 (posterior)を次のように表す：

\begin{align}
    p(\bm{x}, \bm{z}_{1:T}) &= p(\bm{z}_T)p_{\bm{\theta}}(\bm{x}|\bm{z}_1)\prod_{t=2}^{T}p_{\bm{\theta}}(\bm{z}_{t-1}|\bm{z}_{t}) \label{eq:20}\\
    q_{\bm{\phi}}(\bm{z}_{1:T}|\bm{x}) &= q_{\bm{\phi}}(\bm{z}_1|\bm{x})\prod_{t=2}^{T}q_{\bm{\phi}}(\bm{z}_{t}|\bm{z}_{t-1}) \label{eq:21}
\end{align}
ここで，$\Vec{z}_0 = \vec{x}$である．このとき，ELBOは簡単に拡張することができる：
\begin{align}
\log p(\bm{x}) &= \log \int p(\bm{x}, \bm{z}_{1:T}) d\bm{z}_{1:T}         && \text{(Apply Equation \ref{eq:1})}\\
&= \log \int \frac{p(\bm{x}, \bm{z}_{1:T})q_{\bm{\phi}}(\bm{z}_{1:T}|\bm{x})}{q_{\bm{\phi}}(\bm{z}_{1:T}|\bm{x})} d\bm{z}_{1:T}         && \text{(Multiply by 1 = $\frac{q_{\bm{\phi}}(\bm{z}_{1:T}|\bm{x})}{q_{\bm{\phi}}(\bm{z}_{1:T}|\bm{x})}$)}\\
&= \log \mathbb{E}_{q_{\bm{\phi}}(\bm{z}_{1:T}|\bm{x})}\left[\frac{p(\bm{x}, \bm{z}_{1:T})}{q_{\bm{\phi}}(\bm{z}_{1:T}|\bm{x})}\right]         && \text{(Definition of Expectation)}\\
&\geq \mathbb{E}_{q_{\bm{\phi}}(\bm{z}_{1:T}|\bm{x})}\left[\log \frac{p(\bm{x}, \bm{z}_{1:T})}{q_{\bm{\phi}}(\bm{z}_{1:T}|\bm{x})}\right]         && \text{(Apply Jensen's Inequality)} \label{eq:25}
\end{align}


\begin{figure}
  \centering
  %includegraphics[width=0.6\linewidth]{images/hvae.png}
  \caption{A Markovian Hierarchical Variational Autoencoder with $T$ hierarchical latents.  The generative process is modeled as a Markov chain, where each latent $\bm{z}_t$ is generated only from the previous latent $\bm{z}_{t+1}$.}
  \label{fig:hvae}
\end{figure}


次に，結合確率分布 (Equation \ref{eq:20})と事後分布 (Equation \ref{eq:21})をEq.\eqref{eq:25}に代入すると，別の形を得る：
\begin{align}
\mathbb{E}_{q_{\bm{\phi}}(\bm{z}_{1:T}|\bm{x})}\left[\log \frac{p(\bm{x}, \bm{z}_{1:T})}{q_{\bm{\phi}}(\bm{z}_{1:T}|\bm{x})}\right]
&= \mathbb{E}_{q_{\bm{\phi}}(\bm{z}_{1:T}|\bm{x})}\left[\log \frac{p(\bm{z}_T)p_{\bm{\theta}}(\bm{x}|\bm{z}_1)\prod_{t=2}^{T}p_{\bm{\theta}}(\bm{z}_{t-1}|\bm{z}_{t})}{q_{\bm{\phi}}(\bm{z}_1|\bm{x})\prod_{t=2}^{T}q_{\bm{\phi}}(\bm{z}_{t}|\bm{z}_{t-1})}\right]
\end{align}
以下に示すように,変分拡散モデルを調査する場合,この目的はさらに解釈可能な要素に分解することができる.

\begin{figure}
  \centering
  %includegraphics[width=\linewidth]{images/vdm_base.png}
  \caption{A visual representation of a Variational Diffusion Model; $\bm{x}_0$ represents true data observations such as natural images, $\bm{x}_T$ represents pure Gaussian noise, and $\bm{x}_t$ is an intermediate noisy version of $\bm{x}_0$.  Each $q(\bm{x}_t|\bm{x}_{t-1})$ is modeled as a Gaussian distribution that uses the output of the previous state as its mean.}
  \label{fig:vdm}
\end{figure}

\section*{Variational Diffusion Models}
\addcontentsline{toc}{section}{\protect\numberline{}Variational Diffusion Models}%
Variational Diffusion Model (VDM)~\cite{sohl2015deep, ho2020denoising, kingma2021variational}を簡単に理解する方法として，3つの重要な制限を持つMarkovian Hierarchical Variational Autoencoderを考える:
\begin{itemize}
    \item 潜在空間の次元はデータの次元に等しい
    \item 各時刻の潜在空間のencoderの構造は学習されず，線形Gaussianモデルとしてあらかじめ定義されている．すなわち，前のタイムステップの出力を中心とするガウス分布である．
    \item 潜在空間のencoderのGaussianパラメータは、最終タイムステップ$T$での潜在変数の分布が標準ガウス分布になるように、時間とともに変化させる．
\end{itemize}
これらの条件に加えて，さらに，標準的なMHVAEから各階間の遷移がMarkov性を明示的に保つとする．

3つの仮定の意味をもう少し深く説明する．真のデータサンプルと潜在変数の両方を$\vec{x}_t$で表す．ここで，$t=0$のとき，真のデータサンプルを，$t \in \left[1, T\right]$の場合，時刻$t$における階層の潜在変数に対応する．

VDMの事前分布はMHVAE posterior (Equation \ref{eq:21})と同じであるが以下のように書き換える:
\begin{align}
    q(\vec{x}_{1:T}|\vec{x}_0) = \prod_{t = 1}^{T}q(\vec{x}_{t}|\vec{x}_{t-1})
\end{align}
ここで，Encoderに関する確率分布は仮定より，パラメトライズされていない．

2つ目の仮定から，Encoderのそれぞれの潜在変数に関する確率分布はその前の階層の潜在変数を中心とするガウス分布であることがわかる。
Markovian HVAEとは異なり, それぞれの時刻$t$のEncoderの構造は学習されておらず，線形Gaussian modelとして固定されている．ここで，平均と標準偏差はhyperparametersとしてあらかじめ用意されるか~\cite{ho2020denoising}, パラメータとして学習される~\cite{kingma2021variational}.  ここでは，mean $\bm{\mu}_t(\vec{x}_t) = \sqrt{\alpha_t} \vec{x}_{t-1}$, and variance $\bm{\Sigma}_t(\vec{x}_t) = (1 - \alpha_t) \textbf{I}$でGaussian Encoderをパラメータ化する．ここで，係数は潜在変数の分散が同じようなスケールにとどまるように選択される．すなわち，このEncoding プロセスは\textit{variance-preserving} (分散保存)である. 別のGaussianパラーメータ化でき，同様に導出することができる． 重要なことは，$\alpha_t$が階層のdepth $t$に従って変化する潜在的に学習可能な係数であることである．
encoderの遷移は以下のように数学的に表せる:
\begin{align}
    q(\vec{x}_{t}|\vec{x}_{t-1}) = \mathcal{N}(\vec{x}_{t} ; \sqrt{\alpha_t} \vec{x}_{t-1}, (1 - \alpha_t) \textbf{I}) \label{eq:27}
\end{align}
分散が保存することの説明：


3つ目の仮定より， $\alpha_t$が最終時刻$T$に関する潜在変数に関する確率分布$p(\vec{x}_T)$が標準ガウス分布となるように構造化された，固定され学習可能なスケジュールに関して時間発展する．

Markovian HVAE (Equation \ref{eq:20})の結合分布を更新でき，VDMに対する結合分布は以下のように書くことができる: 
\begin{align}
p(\vec{x}_{0:T}) &= p(\vec{x}_T)\prod_{t=1}^{T}p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t) \label{eq:36} \\
\text{where,}&\nonumber\\
p(\vec{x}_T) &= \mathcal{N}(\vec{x}_T; \bm{0}, \textbf{I})
\end{align}

まとめると，時間の経過ともに，入力した画像をノイズ化していく一連の仮定を記述している．
元のデータをGaussianで徐々に汚していき (物理ではLangivan equationによる過程)，最終的に純粋なガウシアンホワイトノイズと完全に同じになるように時間発展を行う．
 Visually, this process is depicted in Figure \ref{fig:vdm}.

各時刻で平均と分散のパラメータが定義されているガウシアンとして完全にモデル化されているため，Encoderの確率分布$q(\vec{x}_t|\vec{x}_{t-1})$はパラメータ$\bm{\phi}$によってパラメータ化されていないことに注意せよ．したがって，VDMでは，学習する条件$p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_{t})$のみに興味がある．VDMの最適化後のサンプリング手順は $p(\vec{x}_T)$からGaussian noiseをサンプリングし，新しいデータである$\vec{x}_0$を生成するために，ディノイジング遷移$p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_{t})$を時刻$T$まで繰り返し実行する.

HVAEと同様にして，VDMもELBOを最大化するように最適化することができる，これは以下のように導出できる：
\begingroup
\allowdisplaybreaks
\begin{align}
{\log p(\vec{x})}
&= {\log \int p(\vec{x}_{0:T}) d\vec{x}_{1:T}}\\
&= {\log \int \frac{p(\vec{x}_{0:T})q(\vec{x}_{1:T}|\vec{x}_0)}{q(\vec{x}_{1:T}|\vec{x}_0)} d\vec{x}_{1:T}}\\
&= {\log \mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\frac{p(\vec{x}_{0:T})}{q(\vec{x}_{1:T}|\vec{x}_0)}\right]}\\
&\geq {\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_{0:T})}{q(\vec{x}_{1:T}|\vec{x}_0)}\right]} \label{eq:34}\\
&= {\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_T)\prod_{t=1}^{T}p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}{\prod_{t = 1}^{T}q(\vec{x}_{t}|\vec{x}_{t-1})}\right]}\\
&= {\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_T)p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)\prod_{t=2}^{T}p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}{q(\vec{x}_T|\vec{x}_{T-1})\prod_{t = 1}^{T-1}q(\vec{x}_{t}|\vec{x}_{t-1})}\right]}\\
&= {\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_T)p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)\prod_{t=1}^{T-1}p_{\bm{\theta}}(\vec{x}_{t}|\vec{x}_{t+1})}{q(\vec{x}_T|\vec{x}_{T-1})\prod_{t = 1}^{T-1}q(\vec{x}_{t}|\vec{x}_{t-1})}\right]}\\
&= {\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_T)p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)}{q(\vec{x}_T|\vec{x}_{T-1})}\right] + \mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \prod_{t = 1}^{T-1}\frac{p_{\bm{\theta}}(\vec{x}_{t}|\vec{x}_{t+1})}{q(\vec{x}_{t}|\vec{x}_{t-1})}\right]}\\
&= {\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)\right] + \mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_T)}{q(\vec{x}_T|\vec{x}_{T-1})}\right] + \mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[ \sum_{t=1}^{T-1} \log \frac{p_{\bm{\theta}}(\vec{x}_{t}|\vec{x}_{t+1})}{q(\vec{x}_{t}|\vec{x}_{t-1})}\right]}\\
&= {\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)\right] + \mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_T)}{q(\vec{x}_T|\vec{x}_{T-1})}\right] + \sum_{t=1}^{T-1}\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[ \log \frac{p_{\bm{\theta}}(\vec{x}_{t}|\vec{x}_{t+1})}{q(\vec{x}_{t}|\vec{x}_{t-1})}\right]}\\
&= {\mathbb{E}_{q(\vec{x}_{1}|\vec{x}_0)}\left[\log p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)\right] + \mathbb{E}_{q(\vec{x}_{T-1}, \vec{x}_T|\vec{x}_0)}\left[\log \frac{p(\vec{x}_T)}{q(\vec{x}_T|\vec{x}_{T-1})}\right] + \sum_{t=1}^{T-1}\mathbb{E}_{q(\vec{x}_{t-1}, \vec{x}_t, \vec{x}_{t+1}|\vec{x}_0)}\left[\log \frac{p_{\bm{\theta}}(\vec{x}_{t}|\vec{x}_{t+1})}{q(\vec{x}_{t}|\vec{x}_{t-1})}\right]}\\
&=  \begin{aligned}[t]
      {\underbrace{\mathbb{E}_{q(\vec{x}_{1}|\vec{x}_0)}\left[\log p_{\theta}(\vec{x}_0|\vec{x}_1)\right]}_\text{reconstruction term}} &- {\underbrace{\mathbb{E}_{q(\vec{x}_{T-1}|\vec{x}_0)}\left[D_{\rm{KL}}{(q(\vec{x}_T|\vec{x}_{T-1})}\|{p(\vec{x}_T))}\right]}_\text{prior matching term}} \\
      &- {\sum_{t=1}^{T-1}\underbrace{\mathbb{E}_{q(\vec{x}_{t-1}, \vec{x}_{t+1}|\vec{x}_0)}\left[D_{\rm{KL}}{(q(\vec{x}_{t}|\vec{x}_{t-1})}\|{p_{\theta}(\vec{x}_{t}|\vec{x}_{t+1}))}\right]}_\text{consistency term}}
    \end{aligned} \label{eq:45}
\end{align}
\endgroup
The derived form of the ELBO can be interpreted in terms of its individual components:

\begin{figure}
  \centering
  %\includegraphics[width=\linewidth]{images/first_derivation.png}
  \caption{Under our first derivation, a VDM can be optimized by ensuring that for every intermediate $\vec{x}_t$, the posterior from the latent above it $p_{\bm{\theta}}(\vec{x}_t|\vec{x}_{t+1})$ matches the Gaussian corruption of the latent before it $q(\vec{x}_t|\vec{x}_{t-1})$.  In this figure, for each intermediate $\vec{x}_t$, we minimize the difference between the distributions represented by the pink and green arrows.}
  \label{fig:first_deriv}
\end{figure}

上のELBOの導出から，それぞれの各項について以下のように解釈できる：
ここで， \eqref{eq:19}の2項は次のように直観的に解釈できる：reconstruction term : $\mathbb{E}_{q_{\bm{\phi}}(\bm{z}|\bm{x})}\left[\log p_{\bm{\theta}}(\bm{x}|\bm{z})\right]$は$\Vec{z}$から$\Vec{x}$に戻せるか？，デコードが正確に行われいるかを測る．この量が大きければ，デコードが正確に行われていることを意味する．

% $\Vec{x}$から$\Vec{z}$を生成に関する確率分布$q_{\bm{\phi}}(\bm{z}|\bm{x})$これは，学習された分布が，元のデータを再生することができる有効な潜在値をモデル化していることを保証する． 

一方で，prior matching term : $D_{\rm{KL}}{q_{\bm{\phi}}(\bm{z}|\bm{x})}{p(\bm{z})}$は，エンコードが正確にできているかその精度を表している．この量が小さければ，エンコードが正確に行われていることを意味する．
\begin{enumerate}
    \item $\mathbb{E}_{q(\vec{x}_{1}|\vec{x}_0)}\left[\log p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)\right]$ は\textit{reconstruction term}として解釈できる$\Vec{x}_1$から元のデータ$\Vec{x}_0$に戻せるか？，デコードが正確に行われいるかを測る．この量が大きければ，デコードが正確に行われていることを意味する．
    \item $\mathbb{E}_{q(\vec{x}_{T-1}|\vec{x}_0)}\left[D_{\rm{KL}}{q(\vec{x}_T|\vec{x}_{T-1})}\|{p(\vec{x}_T)}\right]$は\textit{prior matching term}を表す;最終時刻$T$に関する潜在変数に関する確率分布がガウシアン事前分布に近づいているかを測っている．この量が最小になれば，最終潜在確率分布がガウシアンと一致することを意味する．トレーニング可能なパラメータがないため，この項は最適化を必要としない． 最終分布がガウシアンとなるような十分大きい$T$を取ることによって，この項は友好的に0になる．
    \item $\mathbb{E}_{q(\vec{x}_{t-1}, \vec{x}_{t+1}|\vec{x}_0)}\left[D_{\rm{KL}}{q(\vec{x}_{t}|\vec{x}_{t-1})}{p_{\bm{\theta}}(\vec{x}_{t}|\vec{x}_{t+1})}\right]$ \textit{consistency term}とよぶ; Encode, decodeする過程の両過程において，$\vec{x}_t$に関する確率分布が一致しているかを測っている．つまり，ノイズにまみれた画像からノイズを取り除く過程ときれいな画像にノイズを加え画像を汚す過程は，各タイムステップにおいて一致すべきであるということを表している．
    これは数学的には，KLダイバージェンスに反映されている．この項が最小化されたとき，Equation \ref{eq:27}で定義されているように，ガウス分布 $q(\vec{x}_t|\vec{x}_{t-1})$に一致するように$p_{\theta}(\vec{x}_t|\vec{x}_{t+1})$は学習される．
\end{enumerate}





Visually, this interpretation of the ELBO is depicted in Figure \ref{fig:first_deriv}.  The cost of optimizing a VDM is primarily dominated by the third term, since we must optimize over all timesteps $t$.

Under this derivation, all terms of the ELBO are computed as expectations, and can therefore be approximated using Monte Carlo estimates.  However, actually optimizing the ELBO using the terms we just derived might be suboptimal; because the consistency term is computed as an expectation over two random variables $\left\{\vec{x}_{t-1}, \vec{x}_{t+1}\right\}$ for every timestep, the variance of its Monte Carlo estimate could potentially be higher than a term that is estimated using only one random variable per timestep.  As it is computed by summing up $T-1$ consistency terms, the final estimated value of the ELBO may have high variance for large $T$ values.

Let us instead try to derive a form for our ELBO where each term is computed as an expectation over only one random variable at a time.  The key insight is that we can rewrite encoder transitions as $q(\vec{x}_t|\vec{x}_{t-1}) = q(\vec{x}_t|\vec{x}_{t-1}, \vec{x}_0)$, where the extra conditioning term is superfluous due to the Markov property.  Then, according to Bayes rule, we can rewrite each transition as: 
\begin{align}
q(\vec{x}_t | \vec{x}_{t-1}, \vec{x}_0) = \frac{q(\vec{x}_{t-1}|\vec{x}_t, \vec{x}_0)q(\vec{x}_t|\vec{x}_0)}{q(\vec{x}_{t-1}|\vec{x}_0)}
\end{align}
Armed with this new equation, we can retry the derivation resuming from the ELBO in Equation \ref{eq:34}:
\begingroup
\allowdisplaybreaks
\begin{align}
\scalemath{0.90}{\log p(\vec{x})}
&\geq \scalemath{0.90}{\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_{0:T})}{q(\vec{x}_{1:T}|\vec{x}_0)}\right]}\\
&= \scalemath{0.90}{\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_T)\prod_{t=1}^{T}p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}{\prod_{t = 1}^{T}q(\vec{x}_{t}|\vec{x}_{t-1})}\right]}\\
&= \scalemath{0.90}{\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_T)p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)\prod_{t=2}^{T}p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}{q(\vec{x}_1|\vec{x}_0)\prod_{t = 2}^{T}q(\vec{x}_{t}|\vec{x}_{t-1})}\right]}\\
&= \scalemath{0.90}{\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_T)p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)\prod_{t=2}^{T}p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}{q(\vec{x}_1|\vec{x}_0)\prod_{t = 2}^{T}q(\vec{x}_{t}|\vec{x}_{t-1}, \vec{x}_0)}\right]}\\
&= \scalemath{0.90}{\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p_{\bm{\theta}}(\vec{x}_T)p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)}{q(\vec{x}_1|\vec{x}_0)} + \log \prod_{t=2}^{T}\frac{p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}{q(\vec{x}_{t}|\vec{x}_{t-1}, \vec{x}_0)}\right]}\\
&= \scalemath{0.90}{\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_T)p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)}{q(\vec{x}_1|\vec{x}_0)} + \log \prod_{t=2}^{T}\frac{p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}{\frac{q(\vec{x}_{t-1}|\vec{x}_{t}, \vec{x}_0)q(\vec{x}_t|\vec{x}_0)}{q(\vec{x}_{t-1}|\vec{x}_0)}}\right]}\\
&= \scalemath{0.90}{\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_T)p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)}{q(\vec{x}_1|\vec{x}_0)} + \log \prod_{t=2}^{T}\frac{p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}{\frac{q(\vec{x}_{t-1}|\vec{x}_{t}, \vec{x}_0)\cancel{q(\vec{x}_t|\vec{x}_0)}}{\cancel{q(\vec{x}_{t-1}|\vec{x}_0)}}}\right]}\\
&= \scalemath{0.90}{\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_T)p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)}{\cancel{q(\vec{x}_1|\vec{x}_0)}} + \log \frac{\cancel{q(\vec{x}_1|\vec{x}_0)}}{q(\vec{x}_T|\vec{x}_0)} + \log \prod_{t=2}^{T}\frac{p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}{q(\vec{x}_{t-1}|\vec{x}_{t}, \vec{x}_0)}\right]}\\
&= \scalemath{0.90}{\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_T)p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)}{q(\vec{x}_T|\vec{x}_0)} +  \sum_{t=2}^{T}\log\frac{p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}{q(\vec{x}_{t-1}|\vec{x}_{t}, \vec{x}_0)}\right]}\\
&= \scalemath{0.90}{\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)\right] + \mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_T)}{q(\vec{x}_T|\vec{x}_0)}\right] + \sum_{t=2}^{T}\mathbb{E}_{q(\vec{x}_{1:T}|\vec{x}_0)}\left[\log\frac{p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}{q(\vec{x}_{t-1}|\vec{x}_{t}, \vec{x}_0)}\right]}\\
&= \scalemath{0.90}{\mathbb{E}_{q(\vec{x}_{1}|\vec{x}_0)}\left[\log p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)\right] + \mathbb{E}_{q(\vec{x}_{T}|\vec{x}_0)}\left[\log \frac{p(\vec{x}_T)}{q(\vec{x}_T|\vec{x}_0)}\right] + \sum_{t=2}^{T}\mathbb{E}_{q(\vec{x}_{t}, \vec{x}_{t-1}|\vec{x}_0)}\left[\log\frac{p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}{q(\vec{x}_{t-1}|\vec{x}_{t}, \vec{x}_0)}\right]}\\
&= {\underbrace{\mathbb{E}_{q(\vec{x}_{1}|\vec{x}_0)}\left[\log p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)\right]}_\text{reconstruction term} - \underbrace{D_{\rm{KL}}{q(\vec{x}_T|\vec{x}_0)}{p(\vec{x}_T)}}_\text{prior matching term} - \sum_{t=2}^{T} \underbrace{\mathbb{E}_{q(\vec{x}_{t}|\vec{x}_0)}\left[D_{\rm{KL}}{q(\vec{x}_{t-1}|\vec{x}_t, \vec{x}_0)}{p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}\right]}_\text{denoising matching term}} \label{eq:51}
\end{align}
\endgroup
We have therefore successfully derived an interpretation for the ELBO that can be estimated with lower variance, as each term is computed as an expectation of at most one random variable at a time.  This formulation also has an elegant interpretation, which is revealed when inspecting each individual term:
\begin{enumerate}
    \item $\mathbb{E}_{q(\vec{x}_{1}|\vec{x}_0)}\left[\log p_{\bm{\theta}}(\vec{x}_0|\vec{x}_1)\right]$ can be interpreted as a reconstruction term; like its analogue in the ELBO of a vanilla VAE, this term can be approximated and optimized using a Monte Carlo estimate.
    \item $D_{\rm{KL}}{q(\vec{x}_T|\vec{x}_0)}{p(\vec{x}_T)}$ represents how close the distribution of the final noisified input is to the standard Gaussian prior.  It has no trainable parameters, and is also equal to zero under our assumptions.
    \item $\mathbb{E}_{q(\vec{x}_{t}|\vec{x}_0)}\left[D_{\rm{KL}}{q(\vec{x}_{t-1}|\vec{x}_t, \vec{x}_0)}{p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}\right]$ is a \textit{denoising matching term}.  We learn desired denoising transition step $p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)$ as an approximation to tractable, ground-truth denoising transition step $q(\vec{x}_{t-1}|\vec{x}_{t}, \vec{x}_0)$.  The $q(\vec{x}_{t-1}|\vec{x}_{t}, \vec{x}_0)$ transition step can act as a ground-truth signal, since it defines how to denoise a noisy image $\vec{x}_t$ with access to what the final, completely denoised image $\vec{x}_0$ should be.  This term is therefore minimized when the two denoising steps match as closely as possible, as measured by their KL Divergence.
\end{enumerate}
As a side note, one observes that in the process of both ELBO derivations (Equation \ref{eq:45} and Equation \ref{eq:51}), only the Markov assumption is used; as a result these formulae will hold true for any arbitrary Markovian HVAE.  Furthermore, when we set $T=1$, both of the ELBO interpretations for a VDM exactly recreate the ELBO equation of a vanilla VAE, as written in Equation \ref{eq:19}.

In this derivation of the ELBO, the bulk of the optimization cost once again lies in the summation term, which dominates the reconstruction term.  Whereas each KL Divergence term $D_{\rm{KL}}{q(\vec{x}_{t-1}|\vec{x}_t, \vec{x}_0)}{p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}$ is difficult to minimize for arbitrary posteriors in arbitrarily complex Markovian HVAEs due to the added complexity of simultaneously learning the encoder, in a VDM we can leverage the Gaussian transition assumption to make optimization tractable.  By Bayes rule, we have:
$$q(\vec{x}_{t-1}|\vec{x}_t, \vec{x}_0) = \frac{q(\vec{x}_t | \vec{x}_{t-1}, \vec{x}_0)q(\vec{x}_{t-1}|\vec{x}_0)}{q(\vec{x}_{t}|\vec{x}_0)}$$
\begin{figure}
  \centering
  %\includegraphics[width=\linewidth]{images/second_derivation.png}
  \caption{Depicted is an alternate, lower-variance method to optimize a VDM; we compute the form of ground-truth denoising step $q(\vec{x}_{t-1}|\vec{x}_t, \vec{x}_0)$ using Bayes rule, and minimize its KL Divergence with our approximate denoising step $p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)$.  This is once again denoted visually by matching the distributions represented by the green arrows with those of the pink arrows.  Artistic liberty is at play here; in the full picture, each pink arrow must also stem from $\vec{x}_0$, as it is also a conditioning term.}
  \label{fig:second_deriv}
\end{figure}As we already know that $q(\vec{x}_t | \vec{x}_{t-1}, \vec{x}_0) = q(\vec{x}_t | \vec{x}_{t-1}) = \mathcal{N}(\vec{x}_{t} ; \sqrt{\alpha_t} \vec{x}_{t-1}, (1 - \alpha_t)\textbf{I})$ from our assumption regarding encoder transitions (Equation \ref{eq:27}), what remains is deriving for the forms of $q(\vec{x}_t|\vec{x}_0)$ and $q(\vec{x}_{t-1}|\vec{x}_0)$.  Fortunately, these are also made tractable by utilizing the fact that the encoder transitions of a VDM are linear Gaussian models.  Recall that under the reparameterization trick, samples $\vec{x}_t \sim q(\vec{x}_t | \vec{x}_{t-1})$ can be rewritten as:
\begin{align}
    \vec{x}_t = \sqrt{\alpha_t}\vec{x}_{t-1} + \sqrt{1 - \alpha_t}\bm{\epsilon} \quad \text{with } \bm{\epsilon} \sim \mathcal{N}(\bm{\epsilon}; \bm{0}, \textbf{I})
\end{align}
and that similarly, samples $\vec{x}_{t-1} \sim q(\vec{x}_{t-1} | \vec{x}_{t-2})$ can be rewritten as:
\begin{align}
    \vec{x}_{t-1} = \sqrt{\alpha_{t-1}}\vec{x}_{t-2} + \sqrt{1 - \alpha_{t-1}}\bm{\epsilon} \quad \text{with } \bm{\epsilon} \sim \mathcal{N}(\bm{\epsilon}; \bm{0}, \textbf{I})
\end{align}
Then, the form of $q(\vec{x}_t|\vec{x}_0)$ can be recursively derived through repeated applications of the reparameterization trick.
Suppose that we have access to 2$T$ random noise variables $\{\bm{\epsilon}_t^*,\bm{\epsilon}_t\}_{t=0}^T \iid \mathcal{N}(\bm{\epsilon}; \bm{0},\textbf{I})$.  Then, for an arbitrary sample $\vec{x}_t \sim q(\vec{x}_t|\vec{x}_0)$, we can rewrite it as:
\begingroup
\begin{align}
\vec{x}_t  &= \sqrt{\alpha_t}\vec{x}_{t-1} + \sqrt{1 - \alpha_t}\bm{\epsilon}_{t-1}^*\\
&= \sqrt{\alpha_t}\left(\sqrt{\alpha_{t-1}}\vec{x}_{t-2} + \sqrt{1 - \alpha_{t-1}}\bm{\epsilon}_{t-2}^*\right) + \sqrt{1 - \alpha_t}\bm{\epsilon}_{t-1}^*\\
&= \sqrt{\alpha_t\alpha_{t-1}}\vec{x}_{t-2} + \sqrt{\alpha_t - \alpha_t\alpha_{t-1}}\bm{\epsilon}_{t-2}^* + \sqrt{1 - \alpha_t}\bm{\epsilon}_{t-1}^*\\
&= \sqrt{\alpha_t\alpha_{t-1}}\vec{x}_{t-2} + \sqrt{\sqrt{\alpha_t - \alpha_t\alpha_{t-1}}^2 + \sqrt{1 - \alpha_t}^2}\bm{\epsilon}_{t-2} \label{eq:63}\\
&= \sqrt{\alpha_t\alpha_{t-1}}\vec{x}_{t-2} + \sqrt{\alpha_t - \alpha_t\alpha_{t-1} + 1 - \alpha_t}\bm{\epsilon}_{t-2}\\
&= \sqrt{\alpha_t\alpha_{t-1}}\vec{x}_{t-2} + \sqrt{1 - \alpha_t\alpha_{t-1}}\bm{\epsilon}_{t-2} \label{eq:66}\\
&= \ldots\\
&= \sqrt{\prod_{i=1}^t\alpha_i}\vec{x}_0 + \sqrt{1 - \prod_{i=1}^t\alpha_i}\bm{\bm{\epsilon}}_0\\
&= \sqrt{\bar\alpha_t}\vec{x}_0 + \sqrt{1 - \bar\alpha_t}\bm{\bm{\epsilon}}_0 \label{eq:68}\\
&\sim \mathcal{N}(\vec{x}_{t} ; \sqrt{\bar\alpha_t}\vec{x}_0, \left(1 - \bar\alpha_t\right)\textbf{I}) \label{eq:61}
\end{align}
where in Equation \ref{eq:63} we have utilized the fact that the \href{https://en.wikipedia.org/wiki/Sum_of_normally_distributed_random_variables}{sum of two independent Gaussian random variables} remains a Gaussian with mean being the sum of the two means, and variance being the sum of the two variances.  Interpreting $\sqrt{1 - \alpha_t}\bm{\epsilon}_{t-1}^*$ as a sample from Gaussian $\mathcal{N}(\bm{0}, (1 - \alpha_t)\textbf{I})$, and $\sqrt{\alpha_t - \alpha_t\alpha_{t-1}}\bm{\epsilon}_{t-2}^*$ as a sample from Gaussian $\mathcal{N}(\bm{0}, (\alpha_t - \alpha_t\alpha_{t-1})\textbf{I})$, we can then treat their sum as a random variable sampled from Gaussian $\mathcal{N}(\bm{0}, (1 - \alpha_t + \alpha_t - \alpha_t\alpha_{t-1})\textbf{I}) = \mathcal{N}(\bm{0}, (1 - \alpha_t\alpha_{t-1})\textbf{I})$.  A sample from this distribution can then be represented using the reparameterization trick as $\sqrt{1 - \alpha_t\alpha_{t-1}}\bm{\epsilon}_{t-2}$, as in Equation \ref{eq:66}.

\newpage
We have therefore derived the Gaussian form of $q(\vec{x}_t|\vec{x}_0)$.  This derivation can be modified to also yield the Gaussian parameterization describing $q(\vec{x}_{t-1}|\vec{x}_0)$.  Now, knowing the forms of both $q(\vec{x}_t|\vec{x}_0)$ and $q(\vec{x}_{t-1}|\vec{x}_0)$, we can proceed to calculate the form of $q(\vec{x}_{t-1}|\vec{x}_t, \vec{x}_0)$ by substituting into the Bayes rule expansion:
\begingroup
\allowdisplaybreaks
\begin{align}
\scalemath{0.94}{q(\vec{x}_{t-1}|\vec{x}_t, \vec{x}_0)}
&= \scalemath{0.94}{\frac{q(\vec{x}_t | \vec{x}_{t-1}, \vec{x}_0)q(\vec{x}_{t-1}|\vec{x}_0)}{q(\vec{x}_{t}|\vec{x}_0)}}\\
&= \scalemath{0.94}{\frac{\mathcal{N}(\vec{x}_{t} ; \sqrt{\alpha_t} \vec{x}_{t-1}, (1 - \alpha_t)\textbf{I})\mathcal{N}(\vec{x}_{t-1} ; \sqrt{\bar\alpha_{t-1}}\vec{x}_0, (1 - \bar\alpha_{t-1}) \textbf{I})}{\mathcal{N}(\vec{x}_{t} ; \sqrt{\bar\alpha_{t}}\vec{x}_0, (1 - \bar\alpha_{t})\textbf{I})}}\\
&\propto \scalemath{0.94}{\text{exp}\left\{-\left[\frac{(\vec{x}_{t} - \sqrt{\alpha_t} \vec{x}_{t-1})^2}{2(1 - \alpha_t)} + \frac{(\vec{x}_{t-1} - \sqrt{\bar\alpha_{t-1}} \vec{x}_0)^2}{2(1 - \bar\alpha_{t-1})} - \frac{(\vec{x}_{t} - \sqrt{\bar\alpha_t} \vec{x}_{0})^2}{2(1 - \bar\alpha_t)} \right]\right\}}\\
&= \scalemath{0.94}{\text{exp}\left\{-\frac{1}{2}\left[\frac{(\vec{x}_{t} - \sqrt{\alpha_t} \vec{x}_{t-1})^2}{1 - \alpha_t} + \frac{(\vec{x}_{t-1} - \sqrt{\bar\alpha_{t-1}} \vec{x}_0)^2}{1 - \bar\alpha_{t-1}} - \frac{(\vec{x}_{t} - \sqrt{\bar\alpha_t} \vec{x}_{0})^2}{1 - \bar\alpha_t} \right]\right\}}\\
&= \scalemath{0.94}{\text{exp}\left\{-\frac{1}{2}\left[\frac{(-2\sqrt{\alpha_t} \vec{x}_{t}\vec{x}_{t-1} + \alpha_t \vec{x}_{t-1}^2)}{1 - \alpha_t} + \frac{(\vec{x}_{t-1}^2 - 2\sqrt{\bar\alpha_{t-1}}\vec{x}_{t-1} \vec{x}_0)}{1 - \bar\alpha_{t-1}} + C(\vec{x}_t, \vec{x}_0)\right]\right\}} \label{eq:73}\\
&\propto \scalemath{0.94}{\text{exp}\left\{-\frac{1}{2}\left[- \frac{2\sqrt{\alpha_t} \vec{x}_{t}\vec{x}_{t-1}}{1 - \alpha_t} + \frac{\alpha_t \vec{x}_{t-1}^2}{1 - \alpha_t} + \frac{\vec{x}_{t-1}^2}{1 - \bar\alpha_{t-1}} - \frac{2\sqrt{\bar\alpha_{t-1}}\vec{x}_{t-1} \vec{x}_0}{1 - \bar\alpha_{t-1}}\right]\right\}}\\
&= \scalemath{0.94}{\text{exp}\left\{-\frac{1}{2}\left[(\frac{\alpha_t}{1 - \alpha_t} + \frac{1}{1 - \bar\alpha_{t-1}})\vec{x}_{t-1}^2 - 2\left(\frac{\sqrt{\alpha_t}\vec{x}_{t}}{1 - \alpha_t} + \frac{\sqrt{\bar\alpha_{t-1}}\vec{x}_0}{1 - \bar\alpha_{t-1}}\right)\vec{x}_{t-1}\right]\right\}}\\
&= \scalemath{0.94}{\text{exp}\left\{-\frac{1}{2}\left[\frac{\alpha_t(1-\bar\alpha_{t-1}) + 1 - \alpha_t}{(1 - \alpha_t)(1 - \bar\alpha_{t-1})}\vec{x}_{t-1}^2 - 2\left(\frac{\sqrt{\alpha_t}\vec{x}_{t}}{1 - \alpha_t} + \frac{\sqrt{\bar\alpha_{t-1}}\vec{x}_0}{1 - \bar\alpha_{t-1}}\right)\vec{x}_{t-1}\right]\right\}}\\
&= \scalemath{0.94}{\text{exp}\left\{-\frac{1}{2}\left[\frac{\alpha_t-\bar\alpha_{t} + 1 - \alpha_t}{(1 - \alpha_t)(1 - \bar\alpha_{t-1})}\vec{x}_{t-1}^2 - 2\left(\frac{\sqrt{\alpha_t}\vec{x}_{t}}{1 - \alpha_t} + \frac{\sqrt{\bar\alpha_{t-1}}\vec{x}_0}{1 - \bar\alpha_{t-1}}\right)\vec{x}_{t-1}\right]\right\}}\\
&= \scalemath{0.94}{\text{exp}\left\{-\frac{1}{2}\left[\frac{1 -\bar\alpha_{t}}{(1 - \alpha_t)(1 - \bar\alpha_{t-1})}\vec{x}_{t-1}^2 - 2\left(\frac{\sqrt{\alpha_t}\vec{x}_{t}}{1 - \alpha_t} + \frac{\sqrt{\bar\alpha_{t-1}}\vec{x}_0}{1 - \bar\alpha_{t-1}}\right)\vec{x}_{t-1}\right]\right\}}\\
&= \scalemath{0.94}{\text{exp}\left\{-\frac{1}{2}\left(\frac{1 -\bar\alpha_{t}}{(1 - \alpha_t)(1 - \bar\alpha_{t-1})}\right)\left[\vec{x}_{t-1}^2 - 2\frac{\left(\frac{\sqrt{\alpha_t}\vec{x}_{t}}{1 - \alpha_t} + \frac{\sqrt{\bar\alpha_{t-1}}\vec{x}_0}{1 - \bar\alpha_{t-1}}\right)}{\frac{1 -\bar\alpha_{t}}{(1 - \alpha_t)(1 - \bar\alpha_{t-1})}}\vec{x}_{t-1}\right]\right\}}\\
&= \scalemath{0.94}{\text{exp}\left\{-\frac{1}{2}\left(\frac{1 -\bar\alpha_{t}}{(1 - \alpha_t)(1 - \bar\alpha_{t-1})}\right)\left[\vec{x}_{t-1}^2 - 2\frac{\left(\frac{\sqrt{\alpha_t}\vec{x}_{t}}{1 - \alpha_t} + \frac{\sqrt{\bar\alpha_{t-1}}\vec{x}_0}{1 - \bar\alpha_{t-1}}\right)(1 - \alpha_t)(1 - \bar\alpha_{t-1})}{1 -\bar\alpha_{t}}\vec{x}_{t-1}\right]\right\}}\\
&= \scalemath{0.94}{\text{exp}\left\{-\frac{1}{2}\left(\frac{1}{\frac{(1 - \alpha_t)(1 - \bar\alpha_{t-1})}{1 -\bar\alpha_{t}}}\right)\left[\vec{x}_{t-1}^2 - 2\frac{\sqrt{\alpha_t}(1-\bar\alpha_{t-1})\vec{x}_{t} + \sqrt{\bar\alpha_{t-1}}(1-\alpha_t)\vec{x}_0}{1 -\bar\alpha_{t}}\vec{x}_{t-1}\right]\right\}}\\
&\propto \scalemath{0.94}{\mathcal{N}(\vec{x}_{t-1} ;} \underbrace{\scalemath{0.94}{\frac{\sqrt{\alpha_t}(1-\bar\alpha_{t-1})\vec{x}_{t} + \sqrt{\bar\alpha_{t-1}}(1-\alpha_t)\vec{x}_0}{1 -\bar\alpha_{t}}}}_{\mu_q(\vec{x}_t, \vec{x}_0)}, \underbrace{\scalemath{0.94}{\frac{(1 - \alpha_t)(1 - \bar\alpha_{t-1})}{1 -\bar\alpha_{t}}\textbf{I}}}_{\bm{\Sigma}_q(t)}) \label{eq:78}
\end{align}
\endgroup
where in Equation \ref{eq:73}, $C(\vec{x}_t, \vec{x}_0)$ is a constant term with respect to $\vec{x}_{t-1}$ computed as a combination of only $\vec{x}_t$, $\vec{x}_0$, and $\alpha$ values; this term is implicitly returned in Equation \ref{eq:78} to complete the square.

We have therefore shown that at each step, $\vec{x}_{t-1} \sim q(\vec{x}_{t-1}| \vec{x}_t, \vec{x}_0)$ is normally distributed, with mean $\bm{\mu}_q(\vec{x}_t, \vec{x}_0)$ that is a function of $\vec{x}_t$ and $\vec{x}_0$, and variance $\bm{\Sigma}_q(t)$ as a function of $\alpha$ coefficients.  These $\alpha$ coefficients are known and fixed at each timestep; they are either set permanently when modeled as hyperparameters, or treated as the current inference output of a network that seeks to model them.  Following Equation \ref{eq:78}, we can rewrite our variance equation as $\bm{\Sigma}_q(t) = \sigma_q^2(t)\textbf{I}$, where:
\begin{align}
    \sigma_q^2(t) = \frac{(1 - \alpha_t)(1 - \bar\alpha_{t-1})}{1 -\bar\alpha_{t}} \label{eq:79}
\end{align}
In order to match approximate denoising transition step $p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)$ to ground-truth denoising transition step $q(\vec{x}_{t-1}| \vec{x}_t, \vec{x}_0)$ as closely as possible, we can also model it as a Gaussian.  Furthermore, as all $\alpha$ terms are known to be frozen at each timestep, we can immediately construct the variance of the approximate denoising transition step to also be $\bm{\Sigma}_q(t) = \sigma_q^2(t)\textbf{I}$.  We must parameterize its mean $\bm{\mu}_{\bm{\theta}}(\vec{x}_t, t)$ as a function of $\vec{x}_t$, however, since $p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)$ does not condition on $\vec{x}_0$.

Recall that the \href{https://en.wikipedia.org/wiki/Kullback\%E2\%80\%93Leibler_divergence#Multivariate_normal_distributions}{KL Divergence between two Gaussian distributions} is:
\begin{align}
D_{\rm{KL}}{\mathcal{N}(\vec{x}; \bm{\mu}_x,\bm{\Sigma}_x)}{\mathcal{N}(\vy; \bm{\mu}_y,\bm{\Sigma}_y)}
&=\frac{1}{2}\left[\log\frac{|\bm{\Sigma}_y|}{|\bm{\Sigma}_x|} - d + \text{tr}(\bm{\Sigma}_y^{-1}\bm{\Sigma}_x)
+ (\bm{\mu}_y-\bm{\mu}_x)^T \bm{\Sigma}_y^{-1} (\bm{\mu}_y-\bm{\mu}_x)\right]
\end{align}
In our case, where we can set the variances of the two Gaussians to match exactly, optimizing the KL Divergence term reduces to minimizing the difference between the means of the two distributions:
\begin{align}
& \quad \,\argmin_{\bm{\theta}} D_{\rm{KL}}{q(\vec{x}_{t-1}|\vec{x}_t, \vec{x}_0)}{p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)} \nonumber \\
&= \argmin_{\bm{\theta}}D_{\rm{KL}}{\mathcal{N}(\vec{x}_{t-1}; \bm{\mu}_q,\bm{\Sigma}_q(t))}{\mathcal{N}(\vec{x}_{t-1}; \bm{\mu}_{\bm{\theta}},\bm{\Sigma}_q(t))}\\
&=\argmin_{\bm{\theta}}\frac{1}{2}\left[\log\frac{|\bm{\Sigma}_q(t)|}{|\bm{\Sigma}_q(t)|} - d + \text{tr}(\bm{\Sigma}_q(t)^{-1}\bm{\Sigma}_q(t))
+ (\bm{\mu}_{\bm{\theta}}-\bm{\mu}_q)^T \bm{\Sigma}_q(t)^{-1} (\bm{\mu}_{\bm{\theta}}-\bm{\mu}_q)\right]\\
&=\argmin_{\bm{\theta}}\frac{1}{2}\left[\log1 - d + d + (\bm{\mu}_{\bm{\theta}}-\bm{\mu}_q)^T \bm{\Sigma}_q(t)^{-1} (\bm{\mu}_{\bm{\theta}}-\bm{\mu}_q)\right]\\
&=\argmin_{\bm{\theta}}\frac{1}{2}\left[(\bm{\mu}_{\bm{\theta}}-\bm{\mu}_q)^T \bm{\Sigma}_q(t)^{-1} (\bm{\mu}_{\bm{\theta}}-\bm{\mu}_q)\right]\\
&=\argmin_{\bm{\theta}}\frac{1}{2}\left[(\bm{\mu}_{\bm{\theta}}-\bm{\mu}_q)^T \left(\sigma_q^2(t)\textbf{I}\right)^{-1} (\bm{\mu}_{\bm{\theta}}-\bm{\mu}_q)\right]\\
&=\argmin_{\bm{\theta}}\frac{1}{2\sigma_q^2(t)}\left[\left\lVert\bm{\mu}_{\bm{\theta}}-\bm{\mu}_q\right\rVert_2^2\right]
\end{align}
where we have written $\bm{\mu}_q$ as shorthand for $\bm{\mu}_q(\vec{x}_t, \vec{x}_0)$, and $\bm{\mu}_{\bm{\theta}}$ as shorthand for $\bm{\mu}_{\bm{\theta}}(\vec{x}_t, t)$ for brevity.  In other words, we want to optimize a $\bm{\mu}_{\bm{\theta}}(\vec{x}_t, t)$ that matches $\bm{\mu}_q(\vec{x}_t, \vec{x}_0)$, which from our derived Equation \ref{eq:78}, takes the form: 
\begin{align}
    \bm{\mu}_q(\vec{x}_t, \vec{x}_0) = \frac{\sqrt{\alpha_t}(1-\bar\alpha_{t-1})\vec{x}_{t} + \sqrt{\bar\alpha_{t-1}}(1-\alpha_t)\vec{x}_0}{1 -\bar\alpha_{t}}
\end{align}
As $\bm{\mu}_{\bm{\theta}}(\vec{x}_t, t)$ also conditions on $\vec{x}_t$, we can match $\bm{\mu}_q(\vec{x}_t, \vec{x}_0)$ closely by setting it to the following form:
\begin{align}
    \bm{\mu}_{\bm{\theta}}(\vec{x}_t, t) = \frac{\sqrt{\alpha_t}(1-\bar\alpha_{t-1})\vec{x}_{t} + \sqrt{\bar\alpha_{t-1}}(1-\alpha_t)\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t)}{1 -\bar\alpha_{t}}
\end{align}
where $\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t)$ is parameterized by a neural network that seeks to predict $\vec{x}_0$ from noisy image $\vec{x}_t$ and time index $t$. Then, the optimization problem simplifies to:
\begingroup
\allowdisplaybreaks
\begin{align}
& \scalemath{0.93}{\quad \,\argmin_{\bm{\theta}} D_{\rm{KL}}{q(\vec{x}_{t-1}|\vec{x}_t, \vec{x}_0)}{p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}} \nonumber \\
&= \scalemath{0.93}{\argmin_{\bm{\theta}}D_{\rm{KL}}{\mathcal{N}\left(\vec{x}_{t-1}; \bm{\mu}_q,\bm{\Sigma}_q\left(t\right)\right)}{\mathcal{N}\left(\vec{x}_{t-1}; \bm{\mu}_{\bm{\theta}},\bm{\Sigma}_q\left(t\right)\right)}}\\
&=\scalemath{0.93}{\argmin_{\bm{\theta}}\frac{1}{2\sigma_q^2(t)}\left[\left\lVert\frac{\sqrt{\alpha_t}(1-\bar\alpha_{t-1})\vec{x}_{t} + \sqrt{\bar\alpha_{t-1}}(1-\alpha_t)\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t)}{1 -\bar\alpha_{t}}-\frac{\sqrt{\alpha_t}(1-\bar\alpha_{t-1})\vec{x}_{t} + \sqrt{\bar\alpha_{t-1}}(1-\alpha_t)\vec{x}_0}{1 -\bar\alpha_{t}}\right\rVert_2^2\right]}\\
&=\scalemath{0.93}{\argmin_{\bm{\theta}}\frac{1}{2\sigma_q^2(t)}\left[\left\lVert\frac{\sqrt{\bar\alpha_{t-1}}(1-\alpha_t)\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t)}{1 -\bar\alpha_{t}}-\frac{\sqrt{\bar\alpha_{t-1}}(1-\alpha_t)\vec{x}_0}{1 -\bar\alpha_{t}}\right\rVert_2^2\right]}\\
&=\scalemath{0.93}{\argmin_{\bm{\theta}}\frac{1}{2\sigma_q^2(t)}\left[\left\lVert\frac{\sqrt{\bar\alpha_{t-1}}(1-\alpha_t)}{1 -\bar\alpha_{t}}\left(\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t) - \vec{x}_0\right)\right\rVert_2^2\right]}\\
&=\scalemath{0.93}{\argmin_{\bm{\theta}}\frac{1}{2\sigma_q^2(t)}\frac{\bar\alpha_{t-1}(1-\alpha_t)^2}{(1 -\bar\alpha_{t})^2}\left[\left\lVert\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t) - \vec{x}_0\right\rVert_2^2\right]} \label{eq:93}
\end{align}
\endgroup
Therefore, optimizing a VDM boils down to learning a neural network to predict the original ground truth image from an arbitrarily noisified version of it~\cite{ho2020denoising}.  Furthermore, minimizing the summation term of our derived ELBO objective (Equation \ref{eq:51}) across all noise levels can be approximated by minimizing the expectation over all timesteps:
\begin{align}
\argmin_{\bm{\theta}}\mathbb{E}_{t\sim U\{2, T\}}\left[\mathbb{E}_{q(\vec{x}_{t}|\vec{x}_0)}\left[D_{\rm{KL}}{q(\vec{x}_{t-1}|\vec{x}_t, \vec{x}_0)}{p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)}\right]\right] \label{eq:94}
\end{align}
which can then be optimized using stochastic samples over timesteps.

\subsubsection*{Learning Diffusion Noise Parameters}
\addcontentsline{toc}{section}{\protect\numberline{}\protect\numberline{}Learning Diffusion Noise Parameters}%
Let us investigate how the noise parameters of a VDM can be jointly learned.  One potential approach is to model $\alpha_t$ using a neural network $\hat\alpha_{\bm{\eta}}(t)$ with parameters $\bm{\eta}$.  However, this is inefficient as inference must be performed multiple times at each timestep $t$ to compute $\bar\alpha_t$.  Whereas caching can mitigate this computational cost, we can also derive an alternate way to learn the diffusion noise parameters. By substituting our variance equation from Equation \ref{eq:79} into our derived per-timestep objective in Equation \ref{eq:93}, we can reduce:
\begin{align}
{\frac{1}{2\sigma_q^2(t)}\frac{\bar\alpha_{t-1}(1-\alpha_t)^2}{(1 -\bar\alpha_{t})^2}\left[\left\lVert\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t) - \vec{x}_0\right\rVert_2^2\right]}
&= {\frac{1}{2\frac{(1 - \alpha_t)(1 - \bar\alpha_{t-1})}{1 -\bar\alpha_{t}}}\frac{\bar\alpha_{t-1}(1-\alpha_t)^2}{(1 -\bar\alpha_{t})^2}\left[\left\lVert\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t) - \vec{x}_0\right\rVert_2^2\right]}\\
&= {\frac{1}{2}\frac{1 -\bar\alpha_{t}}{(1 - \alpha_t)(1 - \bar\alpha_{t-1})}\frac{\bar\alpha_{t-1}(1-\alpha_t)^2}{(1 -\bar\alpha_{t})^2}\left[\left\lVert\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t) - \vec{x}_0\right\rVert_2^2\right]}\\
&= {\frac{1}{2}\frac{\bar\alpha_{t-1}(1-\alpha_t)}{(1 - \bar\alpha_{t-1})(1 -\bar\alpha_{t})}\left[\left\lVert\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t) - \vec{x}_0\right\rVert_2^2\right]}\\
&= {\frac{1}{2}\frac{\bar\alpha_{t-1}-\bar\alpha_t}{(1 - \bar\alpha_{t-1})(1 -\bar\alpha_{t})}\left[\left\lVert\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t) - \vec{x}_0\right\rVert_2^2\right]}\\
&= {\frac{1}{2}\frac{\bar\alpha_{t-1} - \bar\alpha_{t-1}\bar\alpha_t + \bar\alpha_{t-1}\bar\alpha_t-\bar\alpha_t}{(1 - \bar\alpha_{t-1})(1 -\bar\alpha_{t})}\left[\left\lVert\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t) - \vec{x}_0\right\rVert_2^2\right]}\\
&= {\frac{1}{2}\frac{\bar\alpha_{t-1}(1 - \bar\alpha_t) -\bar\alpha_t(1 - \bar\alpha_{t-1})}{(1 - \bar\alpha_{t-1})(1 -\bar\alpha_{t})}\left[\left\lVert\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t) - \vec{x}_0\right\rVert_2^2\right]}\\
&= {\frac{1}{2}\left(\frac{\bar\alpha_{t-1}(1 - \bar\alpha_t)}{(1 - \bar\alpha_{t-1})(1 -\bar\alpha_{t})} -\frac{\bar\alpha_t(1 - \bar\alpha_{t-1})}{(1 - \bar\alpha_{t-1})(1 -\bar\alpha_{t})}\right)\left[\left\lVert\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t) - \vec{x}_0\right\rVert_2^2\right]}\\
&= {\frac{1}{2}\left(\frac{\bar\alpha_{t-1}}{1 - \bar\alpha_{t-1}} -\frac{\bar\alpha_t}{1 -\bar\alpha_{t}}\right)\left[\left\lVert\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t) - \vec{x}_0\right\rVert_2^2\right]} \label{eq:102}
\end{align}
Recall from Equation \ref{eq:61} that $q(\vec{x}_t|\vec{x}_0)$ is a Gaussian of form $\mathcal{N}(\vec{x}_{t} ; \sqrt{\bar\alpha_t}\vec{x}_0, \left(1 - \bar\alpha_t\right)\textbf{I})$.  Then, following the definition of the \href{https://en.wikipedia.org/wiki/Signal-to-noise_ratio#Alternate_definition}{signal-to-noise ratio (SNR)} as $\text{SNR} = \frac{\mu^2}{\sigma^2}$, we can write the SNR at each timestep $t$ as:
\begin{align}
    \text{SNR}(t) &= \frac{\bar\alpha_t}{1 -\bar\alpha_{t}} \label{eq:108}
\end{align}
Then, our derived Equation \ref{eq:102} (and Equation \ref{eq:93}) can be simplified as:
\begin{align}
\frac{1}{2\sigma_q^2(t)}\frac{\bar\alpha_{t-1}(1-\alpha_t)^2}{(1 -\bar\alpha_{t})^2}\left[\left\lVert\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t) - \vec{x}_0\right\rVert_2^2\right] &= \frac{1}{2}\left(\text{SNR}(t-1) -\text{SNR}(t)\right)\left[\left\lVert\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t) - \vec{x}_0\right\rVert_2^2\right] \label{eq:104}
\end{align}
As the name implies, the SNR represents the ratio between the original signal and the amount of noise present; a higher SNR represents more signal and a lower SNR represents more noise.  In a diffusion model, we require the SNR to monotonically decrease as timestep $t$ increases; this formalizes the notion that perturbed input $\vec{x}_t$ becomes increasingly noisy over time, until it becomes identical to a standard Gaussian at $t=T$.

Following the simplification of the objective in Equation \ref{eq:104}, we can directly parameterize the SNR at each timestep using a neural network, and learn it jointly along with the diffusion model.  As the SNR must monotonically decrease over time, we can represent it as:
\begin{align}
    \text{SNR}(t) = \text{exp}(-\omega_{\bm{\eta}}(t)) \label{eq:105}
\end{align}
where $\omega_{\bm{\eta}}(t)$ is modeled as a monotonically increasing neural network with parameters $\bm{\eta}$.  Negating $\omega_{\bm{\eta}}(t)$ results in a monotonically decreasing function, whereas the exponential forces the resulting term to be positive.
Note that the objective in Equation \ref{eq:94} must now optimize over $\bm{\eta}$ as well.  By combining our parameterization of SNR in Equation \ref{eq:105} with our definition of SNR in Equation \ref{eq:108}, we can also explicitly derive elegant forms for the value of $\bar\alpha_t$ as well as for the value of $1 - \bar\alpha_t$:
\begin{align}
    &\frac{\bar\alpha_t}{1 -\bar\alpha_{t}} = \text{exp}(-\omega_{\bm{\eta}}(t))\\
    &\therefore \bar\alpha_t = \text{sigmoid}(-\omega_{\bm{\eta}}(t))\\
    &\therefore 1 - \bar\alpha_t = \text{sigmoid}(\omega_{\bm{\eta}}(t))
\end{align}
These terms are necessary for a variety of computations; for example, during optimization, they are used to create arbitrarily noisy $\vec{x}_t$ from input $\vec{x}_0$ using the reparameterization trick, as derived in Equation \ref{eq:68}.
\subsubsection*{Three Equivalent Interpretations}
\addcontentsline{toc}{section}{\protect\numberline{}\protect\numberline{}Three Equivalent Interpretations}%
As we previously proved, a Variational Diffusion Model can be trained by simply learning a neural network to predict the original natural image $\vec{x}_0$ from an arbitrary noised version $\vec{x}_t$ and its time index $t$.  However, $\vec{x}_0$ has two other equivalent parameterizations, which leads to two further interpretations for a VDM.

Firstly, we can utilize the reparameterization trick.  In our derivation of the form of $q(\vec{x}_t|\vec{x}_0)$, we can rearrange Equation \ref{eq:68} to show that:
\begin{align}
\vec{x}_0 &= \frac{\vec{x}_t - \sqrt{1 - \bar\alpha_t}\bm{\epsilon}_0}{\sqrt{\bar\alpha_t}} \label{eq:62}
\end{align}
Plugging this into our previously derived true denoising transition mean $\bm{\mu}_q(\vec{x}_t, \vec{x}_0)$, we can rederive as:
\begingroup
\allowdisplaybreaks
\begin{align}
\bm{\mu}_q(\vec{x}_t, \vec{x}_0) &= \frac{\sqrt{\alpha_t}(1-\bar\alpha_{t-1})\vec{x}_{t} + \sqrt{\bar\alpha_{t-1}}(1-\alpha_t)\vec{x}_0}{1 -\bar\alpha_{t}}\\
&= \frac{\sqrt{\alpha_t}(1-\bar\alpha_{t-1})\vec{x}_{t} + \sqrt{\bar\alpha_{t-1}}(1-\alpha_t)\frac{\vec{x}_t - \sqrt{1 - \bar\alpha_t}\bm{\epsilon}_0}{\sqrt{\bar\alpha_t}}}{1 -\bar\alpha_{t}}\\
&= \frac{\sqrt{\alpha_t}(1-\bar\alpha_{t-1})\vec{x}_{t} + (1-\alpha_t)\frac{\vec{x}_t - \sqrt{1 - \bar\alpha_t}\bm{\epsilon}_0}{\sqrt{\alpha_t}}}{1 -\bar\alpha_{t}}\\
&= \frac{\sqrt{\alpha_t}(1-\bar\alpha_{t-1})\vec{x}_{t}}{1 - \bar\alpha_t} + \frac{(1-\alpha_t)\vec{x}_t}{(1-\bar\alpha_t)\sqrt{\alpha_t}} - \frac{(1 - \alpha_t)\sqrt{1 - \bar\alpha_t}\bm{\epsilon}_0}{(1-\bar\alpha_t)\sqrt{\alpha_t}}\\
&= \left(\frac{\sqrt{\alpha_t}(1-\bar\alpha_{t-1})}{1 - \bar\alpha_t} + \frac{1-\alpha_t}{(1-\bar\alpha_t)\sqrt{\alpha_t}}\right)\vec{x}_t - \frac{(1 - \alpha_t)\sqrt{1 - \bar\alpha_t}}{(1-\bar\alpha_t)\sqrt{\alpha_t}}\bm{\epsilon}_0\\
&= \left(\frac{\alpha_t(1-\bar\alpha_{t-1})}{(1 - \bar\alpha_t)\sqrt{\alpha_t}} + \frac{1-\alpha_t}{(1-\bar\alpha_t)\sqrt{\alpha_t}}\right)\vec{x}_t - \frac{1 - \alpha_t}{\sqrt{1 - \bar\alpha_t}\sqrt{\alpha_t}}\bm{\epsilon}_0\\
&= \frac{\alpha_t-\bar\alpha_{t} + 1-\alpha_t}{(1 - \bar\alpha_t)\sqrt{\alpha_t}}\vec{x}_t - \frac{1 - \alpha_t}{\sqrt{1 - \bar\alpha_t}\sqrt{\alpha_t}}\bm{\epsilon}_0\\
&= \frac{1-\bar\alpha_t}{(1 - \bar\alpha_t)\sqrt{\alpha_t}}\vec{x}_t - \frac{1 - \alpha_t}{\sqrt{1 - \bar\alpha_t}\sqrt{\alpha_t}}\bm{\epsilon}_0\\
&= \frac{1}{\sqrt{\alpha_t}}\vec{x}_t - \frac{1 - \alpha_t}{\sqrt{1 - \bar\alpha_t}\sqrt{\alpha_t}}\bm{\epsilon}_0
\end{align}
Therefore, we can set our approximate denoising transition mean $\bm{\mu}_{\bm{\theta}}(\vec{x}_t, t)$ as:
\begin{align}
\bm{\mu}_{\bm{\theta}}(\vec{x}_t, t) &= \frac{1}{\sqrt{\alpha_t}}\vec{x}_t - \frac{1 - \alpha_t}{\sqrt{1 - \bar\alpha_t}\sqrt{\alpha_t}}\bm{\hat\epsilon}_{\bm{\theta}}(\vec{x}_t, t)
\end{align}
and the corresponding optimization problem becomes:
\begin{align}
& \quad \,\argmin_{\bm{\theta}} D_{\rm{KL}}{q(\vec{x}_{t-1}|\vec{x}_t, \vec{x}_0)}{p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)} \nonumber \\
&= \argmin_{\bm{\theta}}D_{\rm{KL}}{\mathcal{N}\left(\vec{x}_{t-1}; \bm{\mu}_q,\bm{\Sigma}_q\left(t\right)\right)}{\mathcal{N}\left(\vec{x}_{t-1}; \bm{\mu}_{\bm{\theta}},\bm{\Sigma}_q\left(t\right)\right)}\\
&=\argmin_{\bm{\theta}}\frac{1}{2\sigma_q^2(t)}\left[\left\lVert\frac{1}{\sqrt{\alpha_t}}\vec{x}_t - \frac{1 - \alpha_t}{\sqrt{1 - \bar\alpha_t}\sqrt{\alpha_t}}\bm{\hat\epsilon}_{\bm{\theta}}(\vec{x}_t, t) - 
\frac{1}{\sqrt{\alpha_t}}\vec{x}_t + \frac{1 - \alpha_t}{\sqrt{1 - \bar\alpha_t}\sqrt{\alpha_t}}\bm{\epsilon}_0\right\rVert_2^2\right]\\
&=\argmin_{\bm{\theta}}\frac{1}{2\sigma_q^2(t)}\left[\left\lVert \frac{1 - \alpha_t}{\sqrt{1 - \bar\alpha_t}\sqrt{\alpha_t}}\bm{\epsilon}_0 - \frac{1 - \alpha_t}{\sqrt{1 - \bar\alpha_t}\sqrt{\alpha_t}}\bm{\hat\epsilon}_{\bm{\theta}}(\vec{x}_t, t)\right\rVert_2^2\right]\\
&=\argmin_{\bm{\theta}}\frac{1}{2\sigma_q^2(t)}\left[\left\lVert \frac{1 - \alpha_t}{\sqrt{1 - \bar\alpha_t}\sqrt{\alpha_t}}(\bm{\epsilon}_0 - \bm{\hat\epsilon}_{\bm{\theta}}(\vec{x}_t, t))\right\rVert_2^2\right]\\
&=\argmin_{\bm{\theta}}\frac{1}{2\sigma_q^2(t)}\frac{(1 - \alpha_t)^2}{(1 - \bar\alpha_t)\alpha_t}\left[\left\lVert\bm{\epsilon}_0 - \bm{\hat\epsilon}_{\bm{\theta}}(\vec{x}_t, t)\right\rVert_2^2\right]
\end{align}
\endgroup
Here, $\bm{\hat\epsilon}_{\bm{\theta}}(\vec{x}_t, t)$ is a neural network that learns to predict the source noise $\bm{\epsilon}_0 \sim \mathcal{N}(\bm{\epsilon}; \bm{0}, \textbf{I})$ that determines $\vec{x}_t$ from $\vec{x}_0$.  We have therefore shown that learning a VDM by predicting the original image $\vec{x}_0$ is equivalent to learning to predict the noise; empirically, however, some works have found that predicting the noise resulted in better performance \cite{ho2020denoising, saharia2022photorealistic}.

To derive the third common interpretation of Variational Diffusion Models, we appeal to Tweedie's Formula~\cite{efron2011tweedie}.  In English, Tweedie's Formula states that the true mean of an exponential family distribution, given samples drawn from it, can be estimated by the maximum likelihood estimate of the samples (aka empirical mean) plus some correction term involving the score of the estimate.  In the case of just one observed sample, the empirical mean is just the sample itself.  It is commonly used to mitigate sample bias; if observed samples all lie on one end of the underlying distribution, then the negative score becomes large and corrects the naive maximum likelihood estimate of the samples towards the true mean.

Mathematically, for a Gaussian variable $\vz \sim \mathcal{N}(\vz;\bm{\mu}_z, \bm{\Sigma}_z)$, Tweedie's Formula states that: 
$$\mathbb{E}\left[\bm{\mu}_z|\vz\right] = \vz + \bm{\Sigma}_z\nabla_\vz\log p(\vz)$$
In this case, we apply it to predict the true posterior mean of $\vec{x}_t$ given its samples.  From Equation \ref{eq:61}, we know that:
$$q(\vec{x}_t|\vec{x}_0) = \mathcal{N}(\vec{x}_{t} ; \sqrt{\bar\alpha_t}\vec{x}_0, \left(1 - \bar\alpha_t\right)\textbf{I})$$
Then, by Tweedie's Formula, we have:
\begin{align}
\mathbb{E}\left[\bm{\mu}_{x_t}|\vec{x}_t\right] = \vec{x}_t + (1 - \bar\alpha_t)\nabla_{\vec{x}_t}\log p(\vec{x}_t)
\end{align}
where we write $\nabla_{\vec{x}_t}\log p(\vec{x}_t)$ as $\nabla\log p(\vec{x}_t)$ for notational simplicity.
According to Tweedie’s Formula, the best estimate for the true mean that $\vec{x}_t$ is generated from, $\bm{\mu}_{x_t} = \sqrt{\bar\alpha_t}\vec{x}_0$, is defined as:
\begin{align}
    \sqrt{\bar\alpha_t}\vec{x}_0 = \vec{x}_t + (1 - \bar\alpha_t)\nabla\log p(\vec{x}_t)\\
    \therefore \vec{x}_0 = \frac{\vec{x}_t + (1 - \bar\alpha_t)\nabla\log p(\vec{x}_t)}{\sqrt{\bar\alpha_t}} \label{eq:109}
\end{align}
Then, we can plug Equation \ref{eq:109} into our ground-truth denoising transition mean $\bm{\mu}_q(\vec{x}_t, \vec{x}_0)$ once again and derive a new form:
\begin{align}
\bm{\mu}_q(\vec{x}_t, \vec{x}_0) &= \frac{\sqrt{\alpha_t}(1-\bar\alpha_{t-1})\vec{x}_{t} + \sqrt{\bar\alpha_{t-1}}(1-\alpha_t)\vec{x}_0}{1 -\bar\alpha_{t}}\\
&= \frac{\sqrt{\alpha_t}(1-\bar\alpha_{t-1})\vec{x}_{t} + \sqrt{\bar\alpha_{t-1}}(1-\alpha_t)\frac{\vec{x}_t + (1 - \bar\alpha_t)\nabla\log p(\vec{x}_t)}{\sqrt{\bar\alpha_t}}}{1 -\bar\alpha_{t}}\\
&= \frac{\sqrt{\alpha_t}(1-\bar\alpha_{t-1})\vec{x}_{t} + (1-\alpha_t)\frac{\vec{x}_t + (1 - \bar\alpha_t)\nabla\log p(\vec{x}_t)}{\sqrt{\alpha_t}}}{1 -\bar\alpha_{t}}\\
&= \frac{\sqrt{\alpha_t}(1-\bar\alpha_{t-1})\vec{x}_{t}}{1 - \bar\alpha_t} + \frac{(1-\alpha_t)\vec{x}_t}{(1-\bar\alpha_t)\sqrt{\alpha_t}} + \frac{(1 - \alpha_t)(1 - \bar\alpha_t)\nabla\log p(\vec{x}_t)}{(1-\bar\alpha_t)\sqrt{\alpha_t}}\\
&= \left(\frac{\sqrt{\alpha_t}(1-\bar\alpha_{t-1})}{1 - \bar\alpha_t} + \frac{1-\alpha_t}{(1-\bar\alpha_t)\sqrt{\alpha_t}}\right)\vec{x}_t + \frac{1 - \alpha_t}{\sqrt{\alpha_t}}\nabla\log p(\vec{x}_t)\\
&= \left(\frac{\alpha_t(1-\bar\alpha_{t-1})}{(1 - \bar\alpha_t)\sqrt{\alpha_t}} + \frac{1-\alpha_t}{(1-\bar\alpha_t)\sqrt{\alpha_t}}\right)\vec{x}_t + \frac{1 - \alpha_t}{\sqrt{\alpha_t}}\nabla\log p(\vec{x}_t)\\
&= \frac{\alpha_t-\bar\alpha_{t} + 1-\alpha_t}{(1 - \bar\alpha_t)\sqrt{\alpha_t}}\vec{x}_t + \frac{1 - \alpha_t}{\sqrt{\alpha_t}}\nabla\log p(\vec{x}_t)\\
&= \frac{1-\bar\alpha_t}{(1 - \bar\alpha_t)\sqrt{\alpha_t}}\vec{x}_t + \frac{1 - \alpha_t}{\sqrt{\alpha_t}}\nabla\log p(\vec{x}_t)\\
&= \frac{1}{\sqrt{\alpha_t}}\vec{x}_t + \frac{1 - \alpha_t}{\sqrt{\alpha_t}}\nabla\log p(\vec{x}_t)
\end{align}
Therefore, we can also set our approximate denoising transition mean $\bm{\mu}_{\bm{\theta}}(\vec{x}_t, t)$ as:
\begin{align}
\bm{\mu}_{\bm{\theta}}(\vec{x}_t, t) &= \frac{1}{\sqrt{\alpha_t}}\vec{x}_t + \frac{1 - \alpha_t}{\sqrt{\alpha_t}}\vs_{\bm{\theta}}(\vec{x}_t, t)
\end{align}
and the corresponding optimization problem becomes:
\begin{align}
& \quad \,\argmin_{\bm{\theta}} D_{\rm{KL}}{q(\vec{x}_{t-1}|\vec{x}_t, \vec{x}_0)}{p_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)} \nonumber \\
&= \argmin_{\bm{\theta}}D_{\rm{KL}}{\mathcal{N}\left(\vec{x}_{t-1}; \bm{\mu}_q,\bm{\Sigma}_q\left(t\right)\right)}{\mathcal{N}\left(\vec{x}_{t-1}; \bm{\mu}_{\bm{\theta}},\bm{\Sigma}_q\left(t\right)\right)}\\
&=\argmin_{\bm{\theta}}\frac{1}{2\sigma_q^2(t)}\left[\left\lVert\frac{1}{\sqrt{\alpha_t}}\vec{x}_t + \frac{1 - \alpha_t}{\sqrt{\alpha_t}}\vs_{\bm{\theta}}(\vec{x}_t, t) - 
\frac{1}{\sqrt{\alpha_t}}\vec{x}_t - \frac{1 - \alpha_t}{\sqrt{\alpha_t}}\nabla\log p(\vec{x}_t)\right\rVert_2^2\right]\\
&=\argmin_{\bm{\theta}}\frac{1}{2\sigma_q^2(t)}\left[\left\lVert \frac{1 - \alpha_t}{\sqrt{\alpha_t}}\vs_{\bm{\theta}}(\vec{x}_t, t) - \frac{1 - \alpha_t}{\sqrt{\alpha_t}}\nabla\log p(\vec{x}_t)\right\rVert_2^2\right]\\
&=\argmin_{\bm{\theta}}\frac{1}{2\sigma_q^2(t)}\left[\left\lVert \frac{1 - \alpha_t}{\sqrt{\alpha_t}}(\vs_{\bm{\theta}}(\vec{x}_t, t) - \nabla\log p(\vec{x}_t))\right\rVert_2^2\right]\\
&=\argmin_{\bm{\theta}}\frac{1}{2\sigma_q^2(t)}\frac{(1 - \alpha_t)^2}{\alpha_t}\left[\left\lVert \vs_{\bm{\theta}}(\vec{x}_t, t) - \nabla\log p(\vec{x}_t)\right\rVert_2^2\right] \label{eq:123}
\end{align}
Here, $\vs_{\bm{\theta}}(\vec{x}_t, t)$ is a neural network that learns to predict the score function $\nabla_{\vec{x}_t}\log p(\vec{x}_t)$, which is the gradient of $\vec{x}_t$ in data space, for any arbitrary noise level $t$.

The astute reader will notice that the score function $\nabla\log p(\vec{x}_t)$ looks remarkably similar in form to the source noise $\bm{\epsilon}_0$.  This can be shown explicitly by combining Tweedie's Formula (Equation \ref{eq:109}) with the reparameterization trick (Equation \ref{eq:62}):
\begin{align}
\vec{x}_0 = \frac{\vec{x}_t + (1 - \bar\alpha_t)\nabla\log p(\vec{x}_t)}{\sqrt{\bar\alpha_t}} &= \frac{\vec{x}_t - \sqrt{1 - \bar\alpha_t}\bm{\epsilon}_0}{\sqrt{\bar\alpha_t}}\\
\therefore (1 - \bar\alpha_t)\nabla\log p(\vec{x}_t) &= -\sqrt{1 - \bar\alpha_t}\bm{\epsilon}_0\\
\nabla\log p(\vec{x}_t) &= -\frac{1}{\sqrt{1 - \bar\alpha_t}}\bm{\epsilon}_0
\end{align}
As it turns out, the two terms are off by a constant factor that scales with time!  The score function measures how to move in data space to maximize the log probability; intuitively, since the source noise is added to a natural image to corrupt it, moving in its opposite direction "denoises" the image and would be the best update to increase the subsequent log probability.  Our mathematical proof justifies this intuition; we have explicitly shown that learning to model the score function is equivalent to modeling the negative of the source noise (up to a scaling factor).

We have therefore derived three equivalent objectives to optimize a VDM: learning a neural network to predict the original image $\vec{x}_0$, the source noise $\bm{\epsilon}_0$, or the score of the image at an arbitrary noise level $\nabla\log p(\vec{x}_t)$.  The VDM can be scalably trained by stochastically sampling timesteps $t$ and minimizing the norm of the prediction with the ground truth target.

\section*{Score-based Generative Models}
\addcontentsline{toc}{section}{\protect\numberline{}Score-based Generative Models}%
We have shown that a Variational Diffusion Model can be learned simply by optimizing a neural network $\vs_{\bm{\theta}}(\vec{x}_t, t)$ to predict the score function $\nabla\log p(\vec{x}_t)$.  However, in our derivation, the score term arrived from an application of Tweedie's Formula; this doesn't necessarily provide us with great intuition or insight into what exactly the score function is or why it is worth modeling.  Fortunately, we can look to another class of generative models, Score-based Generative Models~\cite{song2019generative, song2020score, song2020improved}, for exactly this intuition.  As it turns out, we can show that the VDM formulation we have previously derived has an equivalent Score-based Generative Modeling formulation, allowing us to flexibly switch between these two interpretations at will.

To begin to understand why optimizing a score function makes sense, we take a detour and revisit energy-based models~\cite{lecun2006tutorial, song2021train}.  Arbitrarily flexible probability distributions can be written in the form:
\begin{align}
    p_{\bm{\theta}}(\vec{x}) = \frac{1}{Z_{\bm{\theta}}}e^{-f_{\bm{\theta}}(\vec{x})} \label{eq:127}
\end{align}
where $f_{\bm{\theta}}(\vec{x})$ is an arbitrarily flexible, parameterizable function called the energy function, often modeled by a neural network, and $Z_{\bm{\theta}}$ is a normalizing constant to ensure that $\int p_{\bm{\theta}}(\vec{x})d\vec{x} = 1$.  One way to learn such a distribution is maximum likelihood; however, this requires tractably computing the normalizing constant $Z_{\bm{\theta}} = \int e^{-f_{\bm{\theta}}(\vec{x})}d\vec{x}$, which may not be possible for complex $f_{\bm{\theta}}(\vec{x})$ functions.

\begin{figure}
  \centering
  %\includegraphics[width=0.45\linewidth]{images/score_3d.jpeg}
  %\includegraphics[width=0.4\linewidth]{images/score_sample.png}
  \caption{Visualization of three random sampling trajectories generated with Langevin dynamics, all starting from the same initialization point, for a Mixture of Gaussians.  The left figure plots these sampling trajectories on a three-dimensional contour, while the right figure plots the sampling trajectories against the ground-truth score function.  From the same initialization point, we are able to generate samples from different modes due to the stochastic noise term in the Langevin dynamics sampling procedure; without it, sampling from a fixed point would always deterministically follow the score to the same mode every trial.}
  \label{fig:langevin_sample}
\end{figure}

One way to avoid calculating or modeling the normalization constant is by using a neural network $\vs_{\bm{\theta}}(\vec{x})$ to learn the score function $\nabla\log p(\vec{x})$  of distribution  $p(\vec{x})$ instead.  This is motivated by the observation that taking the derivative of the log of both sides of Equation \ref{eq:127} yields:
\begin{align}
\nabla_\vec{x} \log p_{\bm{\theta}}(\vec{x})
&= \nabla_\vec{x}\log(\frac{1}{Z_{\bm{\theta}}}e^{-f_{\bm{\theta}}(\vec{x})})\\
&= \nabla_\vec{x}\log\frac{1}{Z_{\bm{\theta}}} + \nabla_\vec{x}\log e^{-f_{\bm{\theta}}(\vec{x})}\\
&= -\nabla_\vec{x} f_{\bm{\theta}}(\vec{x})\\
&\approx \vs_{\bm{\theta}}(\vec{x})
\end{align}
which can be freely represented as a neural network without involving any normalization constants.  The score model can be optimized by minimizing the Fisher Divergence with the ground truth score function:
\begin{align}
    \mathbb{E}_{p(\vec{x})}\left[\left\lVert \vs_{\bm{\theta}}(\vec{x}) - \nabla\log p(\vec{x})\right\rVert_2^2\right] \label{eq:132}
\end{align}
What does the score function represent?  For every $\vec{x}$, taking the gradient of its log likelihood with respect to $\vec{x}$ essentially describes what direction in data space to move in order to further increase its likelihood.  Intuitively, then, the score function defines a vector field over the entire space that data $\vec{x}$ inhabits, pointing towards the modes.  Visually, this is depicted in the right plot of Figure \ref{fig:langevin_sample}.  Then, by learning the score function of the true data distribution, we can generate samples by starting at any arbitrary point in the same space and iteratively following the score until a mode is reached.  This sampling procedure is known as Langevin dynamics, and is mathematically described as:
\begin{align}
    \vec{x}_{i+1} \leftarrow \vec{x}_i + c\nabla\log p(\vec{x}_i) + \sqrt{2c}\bm{\epsilon},\quad i = 0, 1, ..., K
\end{align}
where $\vec{x}_0$ is randomly sampled from a prior distribution (such as uniform), and $\bm{\epsilon} \sim \mathcal{N}(\bm{\epsilon};\bm{0}, \textbf{I})$ is an extra noise term to ensure that the generated samples do not always collapse onto a mode, but hover around it for diversity.  Furthermore, because the learned score function is deterministic, sampling with a noise term involved adds stochasticity to the generative process, allowing us to avoid deterministic trajectories.  This is particularly useful when sampling is initialized from a position that lies between multiple modes.  A visual depiction of Langevin dynamics sampling and the benefits of the noise term is shown in Figure \ref{fig:langevin_sample}.

Note that the objective in Equation \ref{eq:132} relies on having access to the ground truth score function, which is unavailable to us for complex distributions such as the one modeling natural images.  Fortunately, alternative techniques known as score matching~\cite{hyvarinen2005estimation, saremi2018deep, song2020sliced, vincent2011connection} have been derived to minimize this Fisher divergence without knowing the ground truth score, and can be optimized with stochastic gradient descent.

Collectively, learning to represent a distribution as a score function and using it to generate samples through Markov Chain Monte Carlo techniques, such as Langevin dynamics, is known as Score-based Generative Modeling~\cite{song2019generative, song2020score, song2020improved}.

There are three main problems with vanilla score matching, as detailed by ~\citet{song2019generative}.  Firstly, the score function is ill-defined when $\vec{x}$ lies on a low-dimensional manifold in a high-dimensional space.  This can be seen mathematically; all points not on the low-dimensional manifold would have probability zero, the log of which is undefined.  This is particularly inconvenient when trying to learn a generative model over natural images, which is known to lie on a low-dimensional manifold of the entire ambient space.

Secondly, the estimated score function trained via vanilla score matching will not be accurate in low density regions.  This is evident from the objective we minimize in Equation \ref{eq:132}.  Because it is an expectation over $p(\vec{x})$, and explicitly trained on samples from it, the model will not receive an accurate learning signal for rarely seen or unseen examples.  This is problematic, since our sampling strategy involves starting from a random location in the high-dimensional space, which is most likely random noise, and moving according to the learned score function.  Since we are following a noisy or inaccurate score estimate, the final generated samples may be suboptimal as well, or require many more iterations to converge on an accurate output.

Lastly, Langevin dynamics sampling may not mix, even if it is performed using the ground truth scores.  Suppose that the true data distribution is a mixture of two disjoint distributions:
\begin{align}
    p(\vec{x}) = c_1p_1(\vec{x}) + c_2p_2(\vec{x})
\end{align}
Then, when the score is computed, these mixing coefficients are lost, since the log operation splits the coefficient from the distribution and the gradient operation zeros it out.  To visualize this, note that the ground truth score function shown in the right Figure \ref{fig:langevin_sample} is agnostic of the different weights between the three distributions; Langevin dynamics sampling from the depicted initialization point has a roughly equal chance of arriving at each mode, despite the bottom right mode having a higher weight in the actual Mixture of Gaussians.

It turns out that these three drawbacks can be simultaneously addressed by adding multiple levels of Gaussian noise to the data.  Firstly, as the support of a Gaussian noise distribution is the entire space, a perturbed data sample will no longer be confined to a low-dimensional manifold.  Secondly, adding large Gaussian noise will increase the area each mode covers in the data distribution, adding more training signal in low density regions.  Lastly, adding multiple levels of Gaussian noise with increasing variance will result in intermediate distributions that respect the ground truth mixing coefficients.

\newpage
Formally, we can choose a positive sequence of noise levels $\{\sigma_t\}_{t=1}^T$ and define a sequence of progressively perturbed data distributions:
\begin{align}
p_{\sigma_t}(\vec{x}_t) = \int p(\vec{x})\mathcal{N}(\vec{x}_t; \vec{x}, \sigma_t^2\textbf{I})d\vec{x}
\end{align}
Then, a neural network $\vs_{\bm{\theta}}(\vec{x}, t)$ is learned using score matching to learn the score function for all noise levels simultaneously:
\begin{align}
\argmin_{\bm{\theta}} \sum_{t=1}^T\lambda(t)\mathbb{E}_{p_{\sigma_t}(\vec{x}_t)}\left[\left\lVert \vs_{\bm{\theta}}(\vec{x}, t) - \nabla\log p_{\sigma_t}(\vec{x}_t)\right\rVert_2^2\right]
\end{align}
where $\lambda(t)$ is a positive weighting function that conditions on noise level $t$.  Note that this objective almost exactly matches the objective derived in Equation \ref{eq:123} to train a Variational Diffusion Model.  Furthermore, the authors propose annealed Langevin dynamics sampling as a generative procedure, in which samples are produced by running Langevin dynamics for each $t = T, T-1, ..., 2, 1$ in sequence.  The initialization is chosen from some fixed prior (such as uniform), and each subsequent sampling step starts from the final samples of the previous simulation.  Because the noise levels steadily decrease over timesteps $t$, and we reduce the step size over time, the samples eventually converge into a true mode.  This is directly analogous to the sampling procedure performed in the Markovian HVAE interpretation of a Variational Diffusion Model, where a randomly initialized data vector is iteratively refined over decreasing noise levels.

Therefore, we have established an explicit connection between Variational Diffusion Models and Score-based Generative Models, both in their training objectives and sampling procedures.

One question is how to naturally generalize diffusion models to an infinite number of timesteps.  Under the Markovian HVAE view, this can be interpreted as extending the number of hierarchies to infinity $T \rightarrow \infty$.  It is clearer to represent this from the equivalent score-based generative model perspective; under an infinite number of noise scales, the perturbation of an image over continuous time can be represented as a stochastic process, and therefore described by a stochastic differential equation (SDE).  Sampling is then performed by reversing the SDE, which naturally requires estimating the score function at each continuous-valued noise level~\cite{song2020score}.  Different parameterizations of the SDE essentially describe different perturbation schemes over time, enabling flexible modeling of the noising procedure~\cite{kingma2021variational}.

\section*{Guidance}
\addcontentsline{toc}{section}{\protect\numberline{}Guidance}%
So far, we have focused on modeling just the data distribution $p(\vec{x})$.  However, we are often also interested in learning conditional distribution $p(\vec{x}|y)$, which would enable us to explicitly control the data we generate through conditioning information $y$.  This forms the backbone of image super-resolution models such as Cascaded Diffusion Models~\cite{ho2022cascaded}, as well as state-of-the-art image-text models such as DALL-E 2~\cite{ramesh2022hierarchical} and Imagen~\cite{saharia2022photorealistic}.

A natural way to add conditioning information is simply alongside the timestep information, at each iteration.  Recall our joint distribution from Equation \ref{eq:36}:
$$p(\vec{x}_{0:T}) = p(\vec{x}_T)\prod_{t=1}^Tp_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t)$$
Then, to turn this into a conditional diffusion model, we can simply add arbitrary conditioning information $y$ at each transition step as:
\begin{align}
p(\vec{x}_{0:T}|y) = p(\vec{x}_T)\prod_{t=1}^Tp_{\bm{\theta}}(\vec{x}_{t-1}|\vec{x}_t, y)
\end{align}
For example, $y$ could be a text encoding in image-text generation, or a low-resolution image to perform super-resolution on.  We are thus able to learn the core neural networks of a VDM as before, by predicting $\hat \vec{x}_{\bm{\theta}}(\vec{x}_t, t, y) \approx \vec{x}_0$, $\bm{\hat\epsilon}_{\bm{\theta}}(\vec{x}_t, t, y) \approx \bm{\epsilon}_0$, or $\vs_{\bm{\theta}}(\vec{x}_t, t, y) \approx \nabla\log p(\vec{x}_t|y)$ for each desired interpretation and implementation.

A caveat of this vanilla formulation is that a conditional diffusion model trained in this way may potentially learn to ignore or downplay any given conditioning information.  Guidance is therefore proposed as a way to more explicitly control the amount of weight the model gives to the conditioning information, at the cost of sample diversity.  The two most popular forms of guidance are known as Classifier Guidance~\cite{song2020score, dhariwal2021diffusion} and Classifier-Free Guidance~\cite{ho2021classifier}.

\subsubsection*{Classifier Guidance}
\addcontentsline{toc}{section}{\protect\numberline{}\protect\numberline{}Classifier Guidance}%
Let us begin with the score-based formulation of a diffusion model, where our goal is to learn $\nabla\log p(\vec{x}_t|y)$, the score of the conditional model, at arbitrary noise levels $t$.  Recall that $\nabla$ is shorthand for $\nabla_{\vec{x}_t}$ in the interest of brevity.  By Bayes rule, we can derive the following equivalent form:
\begin{align}
\nabla\log p(\vec{x}_t|y) &= \nabla\log \left( \frac{p(\vec{x}_t)p(y|\vec{x}_t)}{p(y)} \right)\\
&= \nabla\log p(\vec{x}_t) + \nabla\log p(y|\vec{x}_t) - \nabla\log p(y)\\
&= \underbrace{\nabla\log p(\vec{x}_t)}_\text{unconditional score} + \underbrace{\nabla\log p(y|\vec{x}_t)}_\text{adversarial gradient} \label{eq:148}
\end{align}
where we have leveraged the fact that the gradient of $\log p(y)$ with respect to $\vec{x}_t$ is zero.

Our final derived result can be interpreted as learning an unconditional score function combined with the adversarial gradient of a classifier $p(y|\vec{x}_t)$.  Therefore, in Classifier Guidance~\cite{song2020score, dhariwal2021diffusion}, the score of an unconditional diffusion model is learned as previously derived, alongside a classifier that takes in arbitrary noisy $\vec{x}_t$ and attempts to predict conditional information $y$.  Then, during the sampling procedure, the overall conditional score function used for annealed Langevin dynamics is computed as the sum of the unconditional score function and the adversarial gradient of the noisy classifier.

In order to introduce fine-grained control to either encourage or discourage the model to consider the conditioning information, Classifier Guidance scales the adversarial gradient of the noisy classifier by a $\gamma$ hyperparameter term.  The score function learned under Classifier Guidance can then be summarized as:
\begin{align}
    \nabla\log p(\vec{x}_t|y) &= \nabla\log p(\vec{x}_t) + \gamma\nabla\log p(y|\vec{x}_t) \label{eq:150}
\end{align}
Intuitively, when $\gamma=0$ the conditional diffusion model learns to ignore the conditioning information entirely, and when $\gamma$ is large the conditional diffusion model learns to produce samples that heavily adhere to the conditioning information.  This would come at the cost of sample diversity, as it would only produce data that would be easy to regenerate the provided conditioning information from, even at noisy levels.

One noted drawback of Classifier Guidance is its reliance on a separately learned classifier.  Because the classifier must handle arbitrarily noisy inputs, which most existing pretrained classification models are not optimized to do, it must be learned ad hoc alongside the diffusion model.

\subsubsection*{Classifier-Free Guidance}
\addcontentsline{toc}{section}{\protect\numberline{}\protect\numberline{}Classifier-Free Guidance}%
In Classifier-Free Guidance~\cite{ho2021classifier}, the authors ditch the training of a separate classifier model in favor of an unconditional diffusion model and a conditional diffusion model.  To derive the score function under Classifier-Free Guidance, we can first rearrange Equation \ref{eq:148} to show that:
\begin{align}
    \nabla\log p(y|\vec{x}_t) = \nabla\log p(\vec{x}_t|y) - \nabla\log p(\vec{x}_t)
\end{align}
Then, substituting this into Equation \ref{eq:150}, we get:
\begin{align}
\nabla\log p(\vec{x}_t|y)
&= \nabla\log p(\vec{x}_t) + \gamma\left(\nabla\log p(\vec{x}_t|y) - \nabla\log p(\vec{x}_t)\right)\\
&= \nabla\log p(\vec{x}_t) + \gamma\nabla\log p(\vec{x}_t|y) - \gamma\nabla\log p(\vec{x}_t)\\
&= \underbrace{\gamma\nabla\log p(\vec{x}_t|y)}_\text{conditional score} + \underbrace{(1 - \gamma)\nabla\log p(\vec{x}_t)}_\text{unconditional score}
\end{align}
Once again, $\gamma$ is a term that controls how much our learned conditional model cares about the conditioning information.  When $\gamma = 0$, the learned conditional model completely ignores the conditioner and learns an unconditional diffusion model.  When $\gamma = 1$, the model explicitly learns the vanilla conditional distribution without guidance.  When $\gamma > 1$, the diffusion model not only prioritizes the conditional score function, but also moves in the direction away from the unconditional score function.  In other words, it reduces the probability of generating samples that do not use conditioning information, in favor of the samples that explicitly do.  This also has the effect of decreasing sample diversity at the cost of generating samples that accurately match the conditioning information.

Because learning two separate diffusion models is expensive, we can learn both the conditional and unconditional diffusion models together as a singular conditional model; the unconditional diffusion model can be queried by replacing the conditioning information with fixed constant values, such as zeros.  This is essentially performing random dropout on the conditioning information.  Classifier-Free Guidance is elegant because it enables us greater control over our conditional generation procedure while requiring nothing beyond the training of a singular diffusion model.

\section*{Closing}
\addcontentsline{toc}{section}{\protect\numberline{}Closing}%
Allow us to recapitulate our findings over the course of our explorations.  First, we derive Variational Diffusion Models as a special case of a Markovian Hierarchical Variational Autoencoder, where three key assumptions enable tractable computation and scalable optimization of the ELBO.  We then prove that optimizing a VDM boils down to learning a neural network to predict one of three potential objectives: the original source image from any arbitrary noisification of it, the original source noise from any arbitrarily noisified image, or the score function of a noisified image at any arbitrary noise level.  Then, we dive deeper into what it means to learn the score function, and connect it explicitly with the perspective of Score-based Generative Modeling.  Lastly, we cover how to learn a conditional distribution using diffusion models.

In summary, diffusion models have shown incredible capabilities as generative models; indeed, they power the current state-of-the-art models on text-conditioned image generation such as Imagen and DALL-E 2.  Furthermore, the mathematics that enable these models are exceedingly elegant.  However, there still remain a few drawbacks to consider:
\begin{itemize}
    \item It is unlikely that this is how we, as humans, naturally model and generate data; we do not generate samples as random noise that we iteratively denoise.
    \item The VDM does not produce interpretable latents.  Whereas a VAE would hopefully learn a structured latent space through the optimization of its encoder, in a VDM the encoder at each timestep is already given as a linear Gaussian model and cannot be optimized flexibly.  Therefore, the intermediate latents are restricted as just noisy versions of the original input.
    \item The latents are restricted to the same dimensionality as the original input, further frustrating efforts to learn meaningful, compressed latent structure.
    \item Sampling is an expensive procedure, as multiple denoising steps must be run under both formulations.  Recall that one of the restrictions is that a large enough number of timesteps $T$ is chosen to ensure the final latent is completely Gaussian noise; during sampling we must iterate over all these timesteps to generate a sample.
\end{itemize}

As a final note, the success of diffusion models highlights the power of Hierarchical VAEs as a generative model.  We have shown that when we generalize to \textit{infinite} latent hierarchies, even if the encoder is trivial and the latent dimension is fixed and Markovian transitions are assumed, we are still able to learn powerful models of data.  This suggests that further performance gains can be achieved in the case of general, deep HVAEs, where complex encoders and semantically meaningful latent spaces can be potentially learned.

\textbf{Acknowledgments:} I would like to acknowledge Josh Dillon, Yang Song, Durk Kingma, Ben Poole, Jonathan Ho, Yiding Jiang, Ting Chen, Jeremy Cohen, and Chen Sun for reviewing drafts of this work and providing many helpful edits and comments.  Thanks so much!

